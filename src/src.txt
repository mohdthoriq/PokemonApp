./components/common/Button.tsx
==== ./components/common/Button.tsx ====
import React, { useRef, useEffect } from 'react';
import { 
  TouchableOpacity, 
  Text, 
  StyleSheet, 
  ActivityIndicator,
  ViewStyle,
  TextStyle,
  Animated,
  Easing,
  View
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { Theme } from '../../styles/themes';

interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary' | 'outline' | 'danger' | 'success';
  size?: 'small' | 'medium' | 'large';
  loading?: boolean;
  disabled?: boolean;
  style?: ViewStyle;
  textStyle?: TextStyle;
  icon?: string;
  iconPosition?: 'left' | 'right';
}

const Button: React.FC<ButtonProps> = ({
  title,
  onPress,
  variant = 'primary',
  size = 'medium',
  loading = false,
  disabled = false,
  style,
  textStyle,
  icon,
  iconPosition = 'left',
}) => {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (!disabled && !loading) {
      Animated.loop(
        Animated.sequence([
          Animated.timing(glowAnim, {
            toValue: 1,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: false,
          }),
          Animated.timing(glowAnim, {
            toValue: 0,
            duration: 2000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: false,
          }),
        ])
      ).start();
    }
  }, [disabled, loading]);

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.95,
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      friction: 3,
      tension: 40,
      useNativeDriver: true,
    }).start();
  };

  const getButtonStyle = () => {
    const baseStyle = styles.base;
    const variantStyle = styles[variant];
    const sizeStyle = styles[size];
    const disabledStyle = disabled ? styles.disabled : {};
    
    return [baseStyle, variantStyle, sizeStyle, disabledStyle, style];
  };

  const getTextStyle = () => {
    const baseTextStyle = styles.baseText;
    const variantTextStyle = styles[`${variant}Text`];
    const sizeTextStyle = styles[`${size}Text`];
    const disabledTextStyle = disabled ? styles.disabledText : {};
    
    return [baseTextStyle, variantTextStyle, sizeTextStyle, disabledTextStyle, textStyle];
  };

  const getIconColor = () => {
    if (disabled) return Theme.colors.gray[600];
    return variant === 'outline' ? Theme.colors.primary : Theme.colors.white;
  };

  const getIconSize = () => {
    switch (size) {
      case 'small': return 14;
      case 'medium': return 16;
      case 'large': return 18;
      default: return 16;
    }
  };

  const glowOpacity = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 0.8],
  });

  const renderIcon = () => {
    if (!icon) return null;
    
    return (
      <FontAwesome6 
        name={icon as any} 
        size={getIconSize()} 
        color={getIconColor()}
        style={[
          styles.icon,
          iconPosition === 'left' ? styles.iconLeft : styles.iconRight
        ]}
      />
    );
  };

  return (
    <Animated.View style={{ transform: [{ scale: scaleAnim }] }}>
      <TouchableOpacity
        style={getButtonStyle()}
        onPress={onPress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        disabled={disabled || loading}
        activeOpacity={0.8}
      >
        {/* Glow Effect */}
        {!disabled && !loading && (
          <Animated.View 
            style={[
              styles.glowEffect,
              { opacity: glowOpacity }
            ]} 
          />
        )}
        
        {loading ? (
          <ActivityIndicator 
            size="small" 
            color={variant === 'outline' ? Theme.colors.primary : Theme.colors.white} 
          />
        ) : (
          <View style={styles.content}>
            {iconPosition === 'left' && renderIcon()}
            <Text style={getTextStyle()}>{title}</Text>
            {iconPosition === 'right' && renderIcon()}
          </View>
        )}
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  base: {
    borderRadius: 12,
    alignItems: 'center',
    justifyContent: 'center',
    flexDirection: 'row',
    position: 'relative',
    overflow: 'hidden',
    borderWidth: 2,
    ...Theme.shadows.medium,
  },
  baseText: {
    fontFamily: Theme.typography.family.bold,
    textAlign: 'center',
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  glowEffect: {
    position: 'absolute',
    top: -10,
    left: -10,
    right: -10,
    bottom: -10,
    borderRadius: 16,
    backgroundColor: '#FFFFFF',
  },
  content: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
  },
  icon: {
    marginHorizontal: 4,
  },
  iconLeft: {
    marginRight: 8,
  },
  iconRight: {
    marginLeft: 8,
  },
  
  // Variants dengan efek game-like
  primary: {
    backgroundColor: Theme.colors.primary,
    borderColor: '#FF6B6B',
    shadowColor: Theme.colors.primary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  primaryText: {
    color: Theme.colors.white,
  },
  
  secondary: {
    backgroundColor: Theme.colors.secondary,
    borderColor: '#4A7FC8',
    shadowColor: Theme.colors.secondary,
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  secondaryText: {
    color: Theme.colors.white,
  },
  
  outline: {
    backgroundColor: 'transparent',
    borderColor: Theme.colors.primary,
    borderWidth: 3,
  },
  outlineText: {
    color: Theme.colors.primary,
  },
  
  danger: {
    backgroundColor: '#FF4757',
    borderColor: '#FF6B7E',
    shadowColor: '#FF4757',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  dangerText: {
    color: Theme.colors.white,
  },

  success: {
    backgroundColor: '#2ED573',
    borderColor: '#51E88A',
    shadowColor: '#2ED573',
    shadowOffset: { width: 0, height: 4 },
    shadowOpacity: 0.3,
    shadowRadius: 8,
    elevation: 6,
  },
  successText: {
    color: Theme.colors.white,
  },
  
  // Sizes
  small: {
    paddingVertical: 10,
    paddingHorizontal: 16,
    minHeight: 40,
  },
  smallText: {
    fontSize: Theme.typography.size.sm,
  },
  
  medium: {
    paddingVertical: 14,
    paddingHorizontal: 24,
    minHeight: 50,
  },
  mediumText: {
    fontSize: Theme.typography.size.md,
  },
  
  large: {
    paddingVertical: 18,
    paddingHorizontal: 32,
    minHeight: 60,
  },
  largeText: {
    fontSize: Theme.typography.size.lg,
  },
  
  // States
  disabled: {
    backgroundColor: Theme.colors.gray[400],
    borderColor: Theme.colors.gray[500],
    shadowOpacity: 0,
    elevation: 0,
  },
  disabledText: {
    color: Theme.colors.gray[600],
    textShadowColor: 'transparent',
  },
});

export default Button;./components/common/ErrorBoundary.tsx
==== ./components/common/ErrorBoundary.tsx ====
import React, { Component, ErrorInfo, ReactNode } from 'react';
import { View, Text, StyleSheet, Button } from 'react-native';
import { Theme } from '../../styles/themes';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
}

interface State {
  hasError: boolean;
  error?: Error;
}

class ErrorBoundary extends Component<Props, State> {
  public state: State = {
    hasError: false,
  };

  public static getDerivedStateFromError(error: Error): State {
    return { hasError: true, error };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    console.error('Uncaught error:', error, errorInfo);
  }

  public render() {
    if (this.state.hasError) {
      if (this.props.fallback) {
        return this.props.fallback;
      }

      return (
        <View style={styles.container}>
          <Text style={styles.title}>Something went wrong</Text>
          <Text style={styles.message}>
            {this.state.error?.message || 'An unexpected error occurred'}
          </Text>
          <Button
            title="Try Again"
            onPress={() => this.setState({ hasError: false, error: undefined })}
            color={Theme.colors.primary}
          />
        </View>
      );
    }

    return this.props.children;
  }
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
    backgroundColor: Theme.colors.background,
  },
  title: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
  },
  message: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.xl,
  },
});

export default ErrorBoundary;./components/common/ErrorScreen.tsx
==== ./components/common/ErrorScreen.tsx ====
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Button from './Button';
import { Theme } from '../../styles/themes';

interface ErrorScreenProps {
  title?: string;
  message?: string;
  onRetry?: () => void;
  retryButtonText?: string;
  icon?: string;
}

const ErrorScreen: React.FC<ErrorScreenProps> = ({
  title = 'Error',
  message = 'Something went wrong',
  onRetry,
  retryButtonText = 'Try Again',
  icon = 'circle-exclamation',
}) => {
  return (
    <View style={styles.container}>
      <View style={styles.iconContainer}>
        <FontAwesome6 
          name={icon as any} 
          size={80} 
          color={Theme.colors.error} 
        />
      </View>
      
      <Text style={styles.title}>{title}</Text>
      
      <Text style={styles.message}>{message}</Text>
      
      {onRetry && (
        <Button
          title={retryButtonText}
          onPress={onRetry}
          variant="primary"
          style={styles.button}
          icon="rotate-right"
          iconPosition="left"
        />
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
    backgroundColor: Theme.colors.background,
  },
  iconContainer: {
    marginBottom: Theme.spacing.xl,
    padding: Theme.spacing.lg,
    backgroundColor: 'rgba(220, 53, 69, 0.1)',
    borderRadius: 50,
  },
  title: {
    fontSize: Theme.typography.size.xxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
    textAlign: 'center',
  },
  message: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.xl,
    lineHeight: Theme.typography.lineHeight.md,
  },
  button: {
    minWidth: 120,
  },
});

export default ErrorScreen;./components/common/Input.tsx
==== ./components/common/Input.tsx ====
import React, { useState } from 'react';
import { 
  View, 
  TextInput, 
  Text, 
  StyleSheet, 
  TextInputProps,
  ViewStyle,
  TouchableOpacity 
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { Theme } from '../../styles/themes';

interface InputProps extends TextInputProps {
  label?: string;
  error?: string;
  containerStyle?: ViewStyle;
  icon?: string;
  secureTextEntry?: boolean;
}

const Input: React.FC<InputProps> = ({
  label,
  error,
  containerStyle,
  style,
  icon,
  secureTextEntry,
  ...props
}) => {
  const [isPasswordVisible, setIsPasswordVisible] = useState(false);
  const [isFocused, setIsFocused] = useState(false);

  const togglePasswordVisibility = () => {
    setIsPasswordVisible(!isPasswordVisible);
  };

  return (
    <View style={[styles.container, containerStyle]}>
      {label && <Text style={styles.label}>{label}</Text>}
      
      <View style={[
        styles.inputContainer,
        isFocused && styles.inputContainerFocused,
        error && styles.inputContainerError
      ]}>
        {icon && (
          <FontAwesome6 
            name={icon as any} 
            size={20} 
            color={error ? Theme.colors.error : isFocused ? Theme.colors.primary : Theme.colors.text.secondary}
            style={styles.leftIcon}
          />
        )}
        
        <TextInput
          style={[
            styles.input,
            icon && styles.inputWithIcon,
            secureTextEntry && styles.inputWithPassword,
            style,
          ]}
          placeholderTextColor={Theme.colors.gray[400]}
          secureTextEntry={secureTextEntry && !isPasswordVisible}
          onFocus={() => setIsFocused(true)}
          onBlur={() => setIsFocused(false)}
          {...props}
        />
        
        {secureTextEntry && (
          <TouchableOpacity 
            onPress={togglePasswordVisibility}
            style={styles.eyeButton}
          >
            <FontAwesome6 
              name={isPasswordVisible ? 'eye' : 'eye-slash'} 
              size={18} 
              color={Theme.colors.text.secondary}
            />
          </TouchableOpacity>
        )}
      </View>
      
      {error && (
        <View style={styles.errorContainer}>
          <FontAwesome6 name="circle-exclamation" size={14} color={Theme.colors.error} iconStyle='solid'/>
          <Text style={styles.errorText}>{error}</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    marginBottom: Theme.spacing.md,
  },
  label: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.xs,
  },
  inputContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: Theme.colors.border,
    borderRadius: Theme.borders.radius.medium,
    backgroundColor: Theme.colors.surface,
    overflow: 'hidden',
  },
  inputContainerFocused: {
    borderColor: Theme.colors.primary,
    shadowColor: Theme.colors.primary,
    shadowOffset: { width: 0, height: 0 },
    shadowOpacity: 0.2,
    shadowRadius: 8,
    elevation: 4,
  },
  inputContainerError: {
    borderColor: Theme.colors.error,
  },
  input: {
    flex: 1,
    paddingVertical: Theme.spacing.inputPadding.vertical,
    paddingHorizontal: Theme.spacing.inputPadding.horizontal,
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.primary,
  },
  inputWithIcon: {
    paddingLeft: Theme.spacing.sm,
  },
  inputWithPassword: {
    paddingRight: Theme.spacing.sm,
  },
  leftIcon: {
    marginLeft: Theme.spacing.md,
  },
  eyeButton: {
    padding: Theme.spacing.sm,
    marginRight: Theme.spacing.xs,
  },
  errorContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: Theme.spacing.xs,
  },
  errorText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.error,
    marginLeft: Theme.spacing.xs,
  },
});

export default Input;./components/common/Loading.tsx
==== ./components/common/Loading.tsx ====
import React, { useEffect, useRef } from 'react';
import { View, Text, StyleSheet, Animated, Easing } from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { Theme } from '../../styles/themes';

interface LoadingProps {
  size?: 'small' | 'large';
  text?: string;
  type?: 'pokeball' | 'pulse' | 'dots' | 'spinner';
}

const Loading: React.FC<LoadingProps> = ({ 
  size = 'large', 
  text, 
  type = 'spinner' 
}) => {
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const pulseAnim = useRef(new Animated.Value(0)).current;
  const dotAnim1 = useRef(new Animated.Value(0)).current;
  const dotAnim2 = useRef(new Animated.Value(0)).current;
  const dotAnim3 = useRef(new Animated.Value(0)).current;

  useEffect(() => {
    if (type === 'spinner') {
      Animated.loop(
        Animated.timing(rotateAnim, {
          toValue: 1,
          duration: 1500,
          easing: Easing.linear,
          useNativeDriver: true,
        })
      ).start();
    } else if (type === 'pulse') {
      Animated.loop(
        Animated.sequence([
          Animated.timing(pulseAnim, {
            toValue: 1,
            duration: 1000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
          Animated.timing(pulseAnim, {
            toValue: 0,
            duration: 1000,
            easing: Easing.inOut(Easing.ease),
            useNativeDriver: true,
          }),
        ])
      ).start();
    } else if (type === 'dots') {
      const createDotAnimation = (anim: Animated.Value, delay: number) => {
        return Animated.loop(
          Animated.sequence([
            Animated.timing(anim, {
              toValue: 1,
              duration: 600,
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: true,
              delay,
            }),
            Animated.timing(anim, {
              toValue: 0,
              duration: 600,
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: true,
            }),
          ])
        );
      };

      createDotAnimation(dotAnim1, 0).start();
      createDotAnimation(dotAnim2, 200).start();
      createDotAnimation(dotAnim3, 400).start();
    }
  }, [type]);

  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const pulseScale = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.3],
  });

  const pulseOpacity = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.7, 1],
  });

  const dotScale1 = dotAnim1.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.5],
  });

  const dotScale2 = dotAnim2.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.5],
  });

  const dotScale3 = dotAnim3.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.5],
  });

  const renderSpinnerLoader = () => (
    <Animated.View style={[styles.spinnerContainer, { transform: [{ rotate }] }]}>
      <FontAwesome6 name="spinner" size={getIconSize()} color={Theme.colors.primary} iconStyle='solid'/>
    </Animated.View>
  );

  const renderPulseLoader = () => (
    <Animated.View style={[
      styles.pulseContainer, 
      { 
        transform: [{ scale: pulseScale }],
        opacity: pulseOpacity
      }
    ]}>
      <FontAwesome6 name="bolt" size={getIconSize()} color={Theme.colors.types.electric}iconStyle='solid' />
    </Animated.View>
  );

  const renderDotsLoader = () => (
    <View style={styles.dotsContainer}>
      <Animated.View 
        style={[
          styles.dot, 
          { backgroundColor: Theme.colors.primary, transform: [{ scale: dotScale1 }] }
        ]} 
      />
      <Animated.View 
        style={[
          styles.dot, 
          { backgroundColor: Theme.colors.secondary, transform: [{ scale: dotScale2 }] }
        ]} 
      />
      <Animated.View 
        style={[
          styles.dot, 
          { backgroundColor: Theme.colors.types.electric, transform: [{ scale: dotScale3 }] }
        ]} 
      />
    </View>
  );

  const getIconSize = () => {
    return size === 'large' ? 48 : 32;
  };

  const getLoader = () => {
    switch (type) {
      case 'spinner':
        return renderSpinnerLoader();
      case 'pulse':
        return renderPulseLoader();
      case 'dots':
        return renderDotsLoader();
      default:
        return renderSpinnerLoader();
    }
  };

  return (
    <View style={[
      styles.container,
      size === 'small' && styles.containerSmall
    ]}>
      {getLoader()}
      {text && (
        <Text style={[
          styles.text,
          size === 'small' && styles.textSmall
        ]}>
          {text}
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
    backgroundColor: 'transparent',
  },
  containerSmall: {
    padding: Theme.spacing.md,
  },
  text: {
    marginTop: Theme.spacing.lg,
    fontSize: Theme.typography.size.lg,
    color: Theme.colors.text.primary,
    fontFamily: Theme.typography.family.medium,
    textAlign: 'center',
  },
  textSmall: {
    fontSize: Theme.typography.size.md,
    marginTop: Theme.spacing.md,
  },
  spinnerContainer: {
    alignItems: 'center',
    justifyContent: 'center',
  },
  pulseContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'rgba(255, 193, 7, 0.1)',
    borderRadius: 40,
    padding: Theme.spacing.md,
  },
  dotsContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    gap: Theme.spacing.md,
  },
  dot: {
    width: 16,
    height: 16,
    borderRadius: 8,
    ...Theme.shadows.small,
  },
});

export default Loading;./components/common/PokemonCard.tsx
==== ./components/common/PokemonCard.tsx ====
import React, { useRef, useEffect } from 'react';
import { 
  View, 
  Text, 
  Image, 
  StyleSheet, 
  TouchableOpacity, 
  Animated,
  Easing 
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { PokemonListItem } from '../../types/pokemon';
import { Theme } from '../../styles/themes';
import { capitalizeFirst, formatNumber, getTypeColor } from '../../utils/helpers';

interface PokemonCardProps {
  pokemon: PokemonListItem;
  onPress: (pokemon: PokemonListItem) => void;
  pokemonId: number;
  types?: string[];
  isFavorite?: boolean;
  onToggleFavorite?: () => void;
}

const PokemonCard: React.FC<PokemonCardProps> = ({ 
  pokemon, 
  onPress, 
  pokemonId,
  types = [],
  isFavorite = false,
  onToggleFavorite
}) => {
  const scaleAnim = useRef(new Animated.Value(1)).current;
  const rotateAnim = useRef(new Animated.Value(0)).current;
  const glowAnim = useRef(new Animated.Value(0)).current;
  const favoriteAnim = useRef(new Animated.Value(isFavorite ? 1 : 0)).current;

  // Use the official artwork from PokeAPI
  const imageUrl = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/other/official-artwork/${pokemonId}.png`;

  useEffect(() => {
    // Subtle floating animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(glowAnim, {
          toValue: 1,
          duration: 3000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(glowAnim, {
          toValue: 0,
          duration: 3000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();
  }, []);

  useEffect(() => {
    // Favorite animation
    Animated.spring(favoriteAnim, {
      toValue: isFavorite ? 1 : 0,
      useNativeDriver: true,
    }).start();
  }, [isFavorite]);

  const handlePress = () => {
    // Press animation
    Animated.sequence([
      Animated.timing(scaleAnim, {
        toValue: 0.95,
        duration: 100,
        useNativeDriver: true,
      }),
      Animated.timing(scaleAnim, {
        toValue: 1,
        duration: 200,
        easing: Easing.elastic(1.2),
        useNativeDriver: true,
      }),
    ]).start();

    onPress(pokemon);
  };

  const handlePressIn = () => {
    Animated.spring(scaleAnim, {
      toValue: 0.97,
      useNativeDriver: true,
    }).start();

    Animated.timing(rotateAnim, {
      toValue: 1,
      duration: 200,
      easing: Easing.inOut(Easing.ease),
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = () => {
    Animated.spring(scaleAnim, {
      toValue: 1,
      friction: 3,
      tension: 40,
      useNativeDriver: true,
    }).start();

    Animated.timing(rotateAnim, {
      toValue: 0,
      duration: 200,
      easing: Easing.inOut(Easing.ease),
      useNativeDriver: true,
    }).start();
  };

  const handleFavoritePress = () => {
    if (onToggleFavorite) {
      onToggleFavorite();
    }
  };

  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '-5deg'],
  });

  const translateY = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -5],
  });

  const favoriteScale = favoriteAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [1, 1.3],
  });

  const primaryType = types[0] || 'normal';
  const cardColor = getTypeColor(primaryType);

  // Fallback image if the official artwork doesn't exist
  const handleImageError = (e: any) => {
    e.target.src = `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${pokemonId}.png`;
  };

  return (
    <Animated.View 
      style={[
        styles.container,
        { 
          transform: [
            { scale: scaleAnim },
            { rotate },
            { translateY }
          ]
        }
      ]}
    >
      <TouchableOpacity 
        style={[
          styles.card,
          { backgroundColor: cardColor + '20', borderColor: cardColor }
        ]} 
        onPress={handlePress}
        onPressIn={handlePressIn}
        onPressOut={handlePressOut}
        activeOpacity={0.8}
      >
        {/* Favorite Button */}
        {onToggleFavorite && (
          <TouchableOpacity 
            style={styles.favoriteButton}
            onPress={handleFavoritePress}
            hitSlop={{ top: 10, bottom: 10, left: 10, right: 10 }}
          >
            <Animated.View style={{ transform: [{ scale: favoriteScale }] }}>
              <FontAwesome6 
                name={isFavorite ? 'heart' : 'heart-circle-plus'} 
                size={20} 
                color={isFavorite ? '#FF4757' : Theme.colors.white}
                iconStyle='solid'
              />
            </Animated.View>
          </TouchableOpacity>
        )}

        <View style={styles.imageContainer}>
          <Image
            source={{ uri: imageUrl }}
            style={styles.image}
            resizeMode="contain"
            onError={handleImageError}
          />
        </View>
        
        <View style={styles.infoContainer}>
          <Text style={styles.number}>{formatNumber(pokemonId)}</Text>
          <Text style={styles.name}>{capitalizeFirst(pokemon.name)}</Text>
          
          {types.length > 0 && (
            <View style={styles.typesContainer}>
              {types.map((type, index) => (
                <View
                  key={index}
                  style={[
                    styles.typeBadge,
                    { backgroundColor: getTypeColor(type) },
                  ]}
                >
                  <FontAwesome6 
                    name="diamond" 
                    size={8} 
                    color={Theme.colors.white}
                    style={styles.typeIcon}
                    iconStyle='solid'
                  />
                  <Text style={styles.typeText}>{capitalizeFirst(type)}</Text>
                </View>
              ))}
            </View>
          )}
        </View>

        {/* Card Glow Effect */}
        <Animated.View 
          style={[
            styles.cardGlow,
            { backgroundColor: cardColor, opacity: glowAnim }
          ]} 
        />
      </TouchableOpacity>
    </Animated.View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    margin: Theme.spacing.sm,
    maxWidth: '50%',
  },
  card: {
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.md,
    borderWidth: 2,
    ...Theme.shadows.medium,
    position: 'relative',
    overflow: 'hidden',
  },
  favoriteButton: {
    position: 'absolute',
    top: Theme.spacing.sm,
    right: Theme.spacing.sm,
    zIndex: 10,
    backgroundColor: 'rgba(0, 0, 0, 0.3)',
    borderRadius: 15,
    padding: 4,
  },
  imageContainer: {
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: Theme.spacing.sm,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
    borderRadius: Theme.borders.radius.medium,
    padding: Theme.spacing.sm,
  },
  image: {
    width: 80,
    height: 80,
  },
  infoContainer: {
    alignItems: 'center',
  },
  number: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
    marginBottom: Theme.spacing.xs,
  },
  name: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
    textShadowColor: 'rgba(0, 0, 0, 0.1)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  typesContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    flexWrap: 'wrap',
  },
  typeBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: Theme.spacing.sm,
    paddingVertical: Theme.spacing.xs,
    borderRadius: Theme.borders.radius.small,
    margin: Theme.spacing.xs,
    ...Theme.shadows.small,
  },
  typeIcon: {
    marginRight: 4,
  },
  typeText: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
  },
  cardGlow: {
    position: 'absolute',
    top: -20,
    right: -20,
    width: 40,
    height: 40,
    borderRadius: 20,
    opacity: 0.3,
  },
});

export default PokemonCard;./components/layout/BottomTabBar.tsx
==== ./components/layout/BottomTabBar.tsx ====
import React, { useRef, useEffect } from 'react';
import { View, Text, TouchableOpacity, StyleSheet, Animated, Easing } from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { BottomTabBarProps } from '@react-navigation/bottom-tabs';
import { Theme } from '../../styles/themes';

// Type untuk icon names yang tersedia di FontAwesome6
type FontAwesome6IconName = 
  | 'house'
  | 'magnifying-glass'
  | 'compass'
  | 'dragon'
  | 'heart'
  | 'user'
  | 'user-circle'
  | 'gear'
  | 'fingerprint'
  | 'shield-halved'
  | 'bell'
  | 'message'
  | 'circle';

const BottomTabBar: React.FC<BottomTabBarProps> = ({ 
  state, 
  descriptors, 
  navigation 
}) => {
  // Animasi values untuk setiap tab
  const scaleAnimations = state.routes.map(() => useRef(new Animated.Value(1)).current);
  const bounceAnimations = state.routes.map(() => useRef(new Animated.Value(0)).current);
  const glowAnimations = state.routes.map(() => useRef(new Animated.Value(0)).current);

  // Function to get icon name based on route name dengan type yang benar
  const getIconName = (routeName: string): FontAwesome6IconName => {
    const iconMap: { [key: string]: FontAwesome6IconName } = {
      'home': 'house',
      'explore': 'magnifying-glass',
      'discover': 'compass',
      'pokedex': 'dragon',
      'pokemon': 'dragon',
      'favorites': 'heart',
      'favourites': 'heart',
      'profile': 'user',
      'account': 'user-circle',
      'settings': 'gear',
      'biometric': 'fingerprint',
      'security': 'shield-halved',
      'notifications': 'bell',
      'messages': 'message',
    };
    
    return iconMap[routeName.toLowerCase()] || 'circle';
  };

  // Animasi untuk tab aktif
  useEffect(() => {
    state.routes.forEach((_, index) => {
      if (state.index === index) {
        // Bounce animation yang lebih kecil
        Animated.sequence([
          Animated.timing(bounceAnimations[index], {
            toValue: -4, // Diperkecil dari -8
            duration: 150,
            easing: Easing.out(Easing.cubic),
            useNativeDriver: true,
          }),
          Animated.timing(bounceAnimations[index], {
            toValue: 0,
            duration: 200,
            easing: Easing.bounce,
            useNativeDriver: true,
          })
        ]).start();

        // Glow animation
        Animated.loop(
          Animated.sequence([
            Animated.timing(glowAnimations[index], {
              toValue: 1,
              duration: 1500, // Diperlambat
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: false,
            }),
            Animated.timing(glowAnimations[index], {
              toValue: 0.2, // Diperkecil opacity
              duration: 1500,
              easing: Easing.inOut(Easing.ease),
              useNativeDriver: false,
            }),
          ])
        ).start();
      } else {
        bounceAnimations[index].setValue(0);
        glowAnimations[index].stopAnimation();
        glowAnimations[index].setValue(0);
      }
    });
  }, [state.index]);

  const handlePressIn = (index: number) => {
    Animated.spring(scaleAnimations[index], {
      toValue: 0.95, // Diperkecil dari 0.9
      useNativeDriver: true,
    }).start();
  };

  const handlePressOut = (index: number) => {
    Animated.spring(scaleAnimations[index], {
      toValue: 1,
      friction: 3,
      tension: 40,
      useNativeDriver: true,
    }).start();
  };

  return (
    <View style={styles.container}>
      {/* Background dengan gradient effect */}
      <View style={styles.background} />
      
      {state.routes.map((route, index) => {
        const { options } = descriptors[route.key];
        const label = options.title || route.name;
        const isFocused = state.index === index;
        const iconName = getIconName(route.name);
        const iconColor = isFocused ? Theme.colors.white : Theme.colors.text.secondary;

        const onPress = () => {
          const event = navigation.emit({
            type: 'tabPress',
            target: route.key,
            canPreventDefault: true,
          });

          if (!isFocused && !event.defaultPrevented) {
            navigation.navigate(route.name);
          }
        };

        const onLongPress = () => {
          navigation.emit({
            type: 'tabLongPress',
            target: route.key,
          });
        };

        const glowOpacity = glowAnimations[index].interpolate({
          inputRange: [0, 1],
          outputRange: [0.2, 0.6], // Diperkecil range opacity
        });

        return (
          <TouchableOpacity
            key={route.key}
            accessibilityRole="button"
            accessibilityState={isFocused ? { selected: true } : {}}
            accessibilityLabel={options.tabBarAccessibilityLabel}
            onPressIn={() => handlePressIn(index)}
            onPressOut={() => handlePressOut(index)}
            onPress={onPress}
            onLongPress={onLongPress}
            style={styles.tab}
            activeOpacity={0.8}
          >
            <Animated.View 
              style={[
                styles.tabContent,
                {
                  transform: [
                    { scale: scaleAnimations[index] },
                    { translateY: bounceAnimations[index] }
                  ]
                }
              ]}
            >
              {/* Glow Effect yang lebih kecil */}
              {isFocused && (
                <Animated.View 
                  style={[
                    styles.glowEffect,
                    {
                      opacity: glowOpacity,
                      backgroundColor: Theme.colors.primary,
                    }
                  ]} 
                />
              )}
              
              {/* Icon Container yang lebih kecil */}
              <View style={[
                styles.iconContainer,
                isFocused && styles.iconContainerActive
              ]}>
                <FontAwesome6 
                  name={iconName as any} 
                  size={18} // Diperkecil dari 20
                  color={iconColor}
                  style={styles.icon}
                />
              </View>
              
              {/* Label */}
              <Text style={[
                styles.tabText,
                isFocused && styles.tabTextFocused
              ]}>
                {label}
              </Text>

              {/* Active Indicator yang lebih kecil */}
              {isFocused && (
                <Animated.View 
                  style={[
                    styles.activeIndicator,
                    {
                      transform: [
                        { scale: glowAnimations[index].interpolate({
                          inputRange: [0, 1],
                          outputRange: [1, 1.1] // Diperkecil scale
                        })}
                      ]
                    }
                  ]} 
                />
              )}
            </Animated.View>

            {/* Particle Effects yang lebih kecil */}
            {isFocused && (
              <>
                <Animated.View 
                  style={[
                    styles.particle,
                    styles.particle1,
                    {
                      opacity: glowAnimations[index],
                      transform: [
                        { translateY: glowAnimations[index].interpolate({
                          inputRange: [0, 1],
                          outputRange: [0, -6] // Diperkecil jarak
                        })}
                      ]
                    }
                  ]} 
                />
                <Animated.View 
                  style={[
                    styles.particle,
                    styles.particle2,
                    {
                      opacity: glowAnimations[index],
                      transform: [
                        { translateY: glowAnimations[index].interpolate({
                          inputRange: [0, 1],
                          outputRange: [0, -8] // Diperkecil jarak
                        })}
                      ]
                    }
                  ]} 
                />
              </>
            )}
          </TouchableOpacity>
        );
      })}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    backgroundColor: 'transparent',
    paddingHorizontal: Theme.spacing.md,
    paddingBottom: Theme.spacing.md,
    paddingTop: Theme.spacing.sm,
    position: 'relative',
    height: 70, // Fixed height untuk konsistensi
  },
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: Theme.colors.surface,
    borderTopLeftRadius: 20,
    borderTopRightRadius: 20,
    ...Theme.shadows.medium,
    borderTopWidth: 1,
    borderLeftWidth: 1,
    borderRightWidth: 1,
    borderColor: Theme.colors.borderLight,
  },
  tab: {
    flex: 1,
    alignItems: 'center',
    justifyContent: 'center',
    paddingVertical: Theme.spacing.xs,
    position: 'relative',
  },
  tabContent: {
    alignItems: 'center',
    justifyContent: 'center',
    position: 'relative',
    padding: 4,
  },
  glowEffect: {
    position: 'absolute',
    top: -6, // Diperkecil
    width: 40, // Diperkecil dari 60
    height: 40, // Diperkecil dari 60
    borderRadius: 20, // Diperkecil
  },
  iconContainer: {
    width: 36, // Diperkecil dari 44
    height: 36, // Diperkecil dari 44
    borderRadius: 18, // Diperkecil
    alignItems: 'center',
    justifyContent: 'center',
    backgroundColor: 'transparent',
    marginBottom: 4, // Diperkecil
    borderWidth: 1.5, // Diperkecil
    borderColor: 'transparent',
  },
  iconContainerActive: {
    backgroundColor: Theme.colors.primary,
    borderColor: `${Theme.colors.primary}80`, // Dengan opacity
    ...Theme.shadows.small,
  },
  icon: {
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 1,
  },
  tabText: {
    fontSize: 10, // Diperkecil dari Theme.typography.size.xs
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginTop: 2,
    textShadowColor: 'rgba(0, 0, 0, 0.2)',
    textShadowOffset: { width: 0, height: 1 },
    textShadowRadius: 1,
  },
  tabTextFocused: {
    color: Theme.colors.white,
    fontFamily: Theme.typography.family.bold,
    textShadowColor: Theme.colors.primary,
    textShadowOffset: { width: 0, height: 0 },
    textShadowRadius: 6, // Diperkecil
  },
  activeIndicator: {
    width: 4, // Diperkecil dari 6
    height: 4, // Diperkecil dari 6
    borderRadius: 2, // Diperkecil
    backgroundColor: Theme.colors.white,
    marginTop: 3, // Diperkecil
    ...Theme.shadows.small,
  },
  particle: {
    position: 'absolute',
    width: 2, // Diperkecil dari 3
    height: 2, // Diperkecil dari 3
    borderRadius: 1, // Diperkecil
    backgroundColor: Theme.colors.primaryLight,
  },
  particle1: {
    top: -3, // Diperkecil
    left: '35%',
  },
  particle2: {
    top: -5, // Diperkecil
    right: '35%',
  },
});

export default BottomTabBar;./components/layout/Container.tsx
==== ./components/layout/Container.tsx ====
import React from 'react';
import { View, StyleSheet, SafeAreaView, ViewProps } from 'react-native';
import { Theme } from '../../styles/themes';

interface ContainerProps extends ViewProps {
  children: React.ReactNode;
  safeArea?: boolean;
}

const Container: React.FC<ContainerProps> = ({ 
  children, 
  safeArea = true, 
  style, 
  ...props 
}) => {
  const ContainerComponent = safeArea ? SafeAreaView : View;

  return (
    <ContainerComponent 
      style={[styles.container, style]} 
      {...props}
    >
      {children}
    </ContainerComponent>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.background,
  },
});

export default Container;./components/layout/DrawerContent.tsx
==== ./components/layout/DrawerContent.tsx ====
import React from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  TouchableOpacity, 
  ScrollView 
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { DrawerContentComponentProps, DrawerNavigationProp } from '@react-navigation/drawer';
import { Theme } from '../../styles/themes';
import { DrawerParamList } from '../../types/navigation';

type DrawerContentNavigationProp = DrawerNavigationProp<DrawerParamList>;

const DrawerContent: React.FC<DrawerContentComponentProps> = ({ navigation }) => {

  const menuItems = [
    { label: 'Pok√©mon List', screen: 'MainTabs' },
    { label: 'Settings', screen: 'Settings' },
    { label: 'Biometric Settings', screen: 'BiometricSettings' },
    { label: 'Location Settings', screen: 'LocationSettings' },
  ];

  return (
    <View style={styles.container}>
      <View style={styles.header}>
        <Text style={styles.title}>Pokedex App</Text>
        <Text style={styles.subtitle}>Gotta Catch 'Em All!</Text>
      </View>

      <ScrollView style={styles.menuContainer}>
        {menuItems.map((item, idx) => (
          <TouchableOpacity
            key={idx}
            style={styles.menuItem}
            onPress={() => navigation.navigate(item.screen as never)}
          >
            <Text style={styles.menuItemText}>{item.label}</Text>
          </TouchableOpacity>
        ))}
      </ScrollView>

      <View style={styles.footer}>
        <Text style={styles.footerText}>v1.0.0</Text>
      </View>
    </View>
  );
};


const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.surface,
  },
  header: {
    padding: Theme.spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
    backgroundColor: Theme.colors.primary,
  },
  title: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.xs,
  },
  subtitle: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.8,
  },
  menuContainer: {
    flex: 1,
    paddingVertical: Theme.spacing.md,
  },
  menuItem: {
    paddingVertical: Theme.spacing.md,
    paddingHorizontal: Theme.spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
  },
  menuItemText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
  },
  footer: {
    padding: Theme.spacing.lg,
    borderTopWidth: 1,
    borderTopColor: Theme.colors.borderLight,
  },
  footerText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
  },
});

export default DrawerContent;./hooks/useAuth.ts
==== ./hooks/useAuth.ts ====
import { useState, useEffect, useCallback } from 'react';
import { User, AuthCredentials, RegisterData } from '../types/auth';
import AuthStorageService from '../services/storage/auth';
import BiometricAuthService from '../services/biometrics/biometricAuth';

export const useAuth = () => {
  const [user, setUser] = useState<User | null>(null);
  const [isLoading, setIsLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);

  useEffect(() => {
    checkAuthStatus();
  }, []);

  const checkAuthStatus = useCallback(async () => {
    try {
      setIsLoading(true);
      const [userData, isLoggedIn] = await Promise.all([
        AuthStorageService.getUserData(),
        AuthStorageService.isUserLoggedIn(),
      ]);
      
      setUser(userData);
      setIsAuthenticated(isLoggedIn);
    } catch (error) {
      console.error('Error checking auth status:', error);
      setIsAuthenticated(false);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const login = useCallback(async (credentials: AuthCredentials): Promise<boolean> => {
    try {
      // Simulate API login - replace with actual API call
      const mockUser: User = {
        id: '1',
        email: credentials.email,
        username: credentials.email.split('@')[0],
        createdAt: new Date(),
      };

      const success = await AuthStorageService.saveUserCredentials(credentials, mockUser);
      
      if (success) {
        setUser(mockUser);
        setIsAuthenticated(true);
      }
      
      return success;
    } catch (error) {
      console.error('Error during login:', error);
      return false;
    }
  }, []);

  const register = useCallback(async (data: RegisterData): Promise<boolean> => {
    try {
      // Simulate API registration - replace with actual API call
      const mockUser: User = {
        id: Date.now().toString(),
        email: data.email,
        username: data.username,
        createdAt: new Date(),
      };

      const success = await AuthStorageService.saveUserCredentials(data, mockUser);
      
      if (success) {
        setUser(mockUser);
        setIsAuthenticated(true);
      }
      
      return success;
    } catch (error) {
      console.error('Error during registration:', error);
      return false;
    }
  }, []);

  const logout = useCallback(async (): Promise<boolean> => {
    try {
      const success = await AuthStorageService.clearUserData();
      
      if (success) {
        setUser(null);
        setIsAuthenticated(false);
      }
      
      return success;
    } catch (error) {
      console.error('Error during logout:', error);
      return false;
    }
  }, []);

  const biometricLogin = useCallback(async (): Promise<boolean> => {
    try {
      const [isEnabled, isAvailable] = await Promise.all([
        BiometricAuthService.isBiometricEnabled(),
        BiometricAuthService.isBiometricAvailable(),
      ]);

      if (!isEnabled || !isAvailable.available) {
        return false;
      }

      const authenticated = await BiometricAuthService.authenticateWithBiometric();
      
      if (authenticated) {
        const userData = await AuthStorageService.getUserData();
        if (userData) {
          setUser(userData);
          setIsAuthenticated(true);
          return true;
        }
      }
      
      return false;
    } catch (error) {
      console.error('Error during biometric login:', error);
      return false;
    }
  }, []);

  return {
    user,
    isLoading,
    isAuthenticated,
    login,
    register,
    logout,
    biometricLogin,
    checkAuthStatus,
  };
};./hooks/useBiometric.ts
==== ./hooks/useBiometric.ts ====
import { useState, useEffect, useCallback } from 'react';
import BiometricAuthService from '../services/biometrics/biometricAuth';

export const useBiometric = () => {
  const [isAvailable, setIsAvailable] = useState(false);
  const [biometryType, setBiometryType] = useState<string>('');
  const [isEnabled, setIsEnabled] = useState(false);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    checkBiometricStatus();
  }, []);

  const checkBiometricStatus = useCallback(async () => {
    try {
      setIsLoading(true);
      const [availability, enabled] = await Promise.all([
        BiometricAuthService.isBiometricAvailable(),
        BiometricAuthService.isBiometricEnabled(),
      ]);

      setIsAvailable(availability.available);
      setBiometryType(availability.biometryType || '');
      setIsEnabled(enabled);
    } catch (error) {
      console.error('Error checking biometric status:', error);
      setIsAvailable(false);
      setIsEnabled(false);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const enableBiometric = useCallback(async (username: string, password: string): Promise<boolean> => {
    try {
      const success = await BiometricAuthService.enableBiometricAuth(username, password);
      if (success) {
        setIsEnabled(true);
      }
      return success;
    } catch (error) {
      console.error('Error enabling biometric:', error);
      return false;
    }
  }, []);

  const disableBiometric = useCallback(async (): Promise<boolean> => {
    try {
      const success = await BiometricAuthService.disableBiometricAuth();
      if (success) {
        setIsEnabled(false);
      }
      return success;
    } catch (error) {
      console.error('Error disabling biometric:', error);
      return false;
    }
  }, []);

  const authenticate = useCallback(async (): Promise<boolean> => {
    try {
      return await BiometricAuthService.authenticateWithBiometric();
    } catch (error) {
      console.error('Error during biometric authentication:', error);
      return false;
    }
  }, []);

  return {
    isAvailable,
    biometryType,
    isEnabled,
    isLoading,
    enableBiometric,
    disableBiometric,
    authenticate,
    refreshStatus: checkBiometricStatus,
  };
};./hooks/useFavorites.ts
==== ./hooks/useFavorites.ts ====
import { useState, useEffect, useCallback } from 'react';
import FavoritesStorageService from '../services/storage/favorites';

export const useFavorites = () => {
  const [favorites, setFavorites] = useState<number[]>([]);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    loadFavorites();
  }, []);

  const loadFavorites = useCallback(async () => {
    try {
      setIsLoading(true);
      const favoriteIds = await FavoritesStorageService.getFavorites();
      setFavorites(favoriteIds);
    } catch (error) {
      console.error('Error loading favorites:', error);
    } finally {
      setIsLoading(false);
    }
  }, []);

  const addFavorite = useCallback(async (pokemonId: number): Promise<boolean> => {
    try {
      const success = await FavoritesStorageService.addFavorite(pokemonId);
      if (success) {
        setFavorites(prev => [...prev, pokemonId]);
      }
      return success;
    } catch (error) {
      console.error('Error adding favorite:', error);
      return false;
    }
  }, []);

  const removeFavorite = useCallback(async (pokemonId: number): Promise<boolean> => {
    try {
      const success = await FavoritesStorageService.removeFavorite(pokemonId);
      if (success) {
        setFavorites(prev => prev.filter(id => id !== pokemonId));
      }
      return success;
    } catch (error) {
      console.error('Error removing favorite:', error);
      return false;
    }
  }, []);

  const isFavorite = useCallback((pokemonId: number): boolean => {
    return favorites.includes(pokemonId);
  }, [favorites]);

  const toggleFavorite = useCallback(async (pokemonId: number): Promise<boolean> => {
    if (isFavorite(pokemonId)) {
      return await removeFavorite(pokemonId);
    } else {
      return await addFavorite(pokemonId);
    }
  }, [isFavorite, addFavorite, removeFavorite]);

  const clearFavorites = useCallback(async (): Promise<boolean> => {
    try {
      const success = await FavoritesStorageService.clearFavorites();
      if (success) {
        setFavorites([]);
      }
      return success;
    } catch (error) {
      console.error('Error clearing favorites:', error);
      return false;
    }
  }, []);

  return {
    favorites,
    isLoading,
    addFavorite,
    removeFavorite,
    isFavorite,
    toggleFavorite,
    clearFavorites,
    refreshFavorites: loadFavorites,
  };
};./hooks/useLocation.ts
==== ./hooks/useLocation.ts ====
import { useState, useCallback } from 'react';
import { LocationData } from '../types/common';
import LocationService from '../services/location/geolocation';

export const useLocation = () => {
  const [currentLocation, setCurrentLocation] = useState<LocationData | null>(null);
  const [currentAddress, setCurrentAddress] = useState<string>('');
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);

  const getCurrentLocation = useCallback(async (): Promise<LocationData | null> => {
    try {
      setIsLoading(true);
      setError(null);

      const location = await LocationService.getCurrentLocation();
      setCurrentLocation(location);

      // Get address from coordinates
      const address = await LocationService.getCurrentAddress(
        location.latitude,
        location.longitude
      );
      setCurrentAddress(address);

      return location;
    } catch (err) {
      const errorMessage = err instanceof Error ? err.message : 'Failed to get location';
      setError(errorMessage);
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearLocation = useCallback(() => {
    setCurrentLocation(null);
    setCurrentAddress('');
    setError(null);
  }, []);

  const refreshLocation = useCallback(async (): Promise<LocationData | null> => {
    return await getCurrentLocation();
  }, [getCurrentLocation]);

  return {
    currentLocation,
    currentAddress,
    isLoading,
    error,
    getCurrentLocation,
    clearLocation,
    refreshLocation,
  };
};./hooks/usePokemon.ts
==== ./hooks/usePokemon.ts ====
import { useState, useEffect, useCallback } from 'react';
import { Pokemon, PokemonListItem } from '../types/pokemon';
import PokeApiService from '../services/api/pokeapi';

export const usePokemon = () => {
  const [pokemonList, setPokemonList] = useState<PokemonListItem[]>([]);
  const [selectedPokemon, setSelectedPokemon] = useState<Pokemon | null>(null);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [offset, setOffset] = useState(0);
  const [hasMore, setHasMore] = useState(true);

  const fetchPokemonList = useCallback(async (loadMore: boolean = false) => {
    try {
      setIsLoading(true);
      setError(null);

      const currentOffset = loadMore ? offset : 0;
      const response = await PokeApiService.getPokemonList(20, currentOffset);

      if (loadMore) {
        setPokemonList(prev => [...prev, ...response.results]);
      } else {
        setPokemonList(response.results);
      }

      setOffset(currentOffset + 20);
      setHasMore(!!response.next);
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch Pokemon list');
    } finally {
      setIsLoading(false);
    }
  }, [offset]);
  
  const fetchPokemonDetail = useCallback(async (idOrName: string | number) => {
    try {
      setIsLoading(true);
      setError(null);
      const pokemon = await PokeApiService.getPokemonDetail(idOrName);
      setSelectedPokemon(pokemon);
      return pokemon;
    } catch (err) {
      setError(err instanceof Error ? err.message : 'Failed to fetch Pokemon detail');
      return null;
    } finally {
      setIsLoading(false);
    }
  }, []);

  const clearError = useCallback(() => {
    setError(null);
  }, []);

  const refreshList = useCallback(() => {
    setOffset(0);
    fetchPokemonList(false);
  }, [fetchPokemonList]);

  useEffect(() => {
    fetchPokemonList(false);
  }, []);

  return {
    pokemonList,
    selectedPokemon,
    isLoading,
    error,
    hasMore,
    fetchPokemonList: () => fetchPokemonList(true),
    fetchPokemonDetail,
    clearError,
    refreshList,
  };
};./navigation/AppNavigator.tsx
==== ./navigation/AppNavigator.tsx ====
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import AuthNavigator from './AuthNavigator';
import DrawerNavigator from './DrawerNavigator';
import PokemonDetail from '../screens/main/PokemonDetail';
import NotFound from '../screens/main/NotFound';
import { RootStackParamList } from '../types/navigation';
import { useAuth } from '../hooks/useAuth';
import Loading from '../components/common/Loading';
import BiometricSetupScreen from '../screens/main/BiometricSetupScreen';

const Stack = createNativeStackNavigator<RootStackParamList>();

const AppNavigator: React.FC = () => {
  const { isAuthenticated, isLoading } = useAuth();

  if (isLoading) {
    return <Loading text="Checking authentication..." />;
  }

  return (
    <Stack.Navigator
      screenOptions={{
        headerShown: false,
        animation: 'slide_from_right',
      }}
    >
      {!isAuthenticated ? (
        <Stack.Screen name="Auth" component={AuthNavigator} />
      ) : (
        <>
          <Stack.Screen name="Main" component={DrawerNavigator} />
          <Stack.Screen
            name="PokemonDetail"
            component={PokemonDetail}
            options={{
              headerShown: true,
              title: 'Pok√©mon Detail',
              headerStyle: {
                backgroundColor: '#DC0A2D',
              },
              headerTintColor: '#FFFFFF',
            }}
          />
        </>
      )}
      <Stack.Screen
        name="NotFound"
        component={NotFound}
        options={{ title: 'Not Found' }}
      />
      <Stack.Screen
        name="BiometricSetup"
        component={BiometricSetupScreen}
        options={{
          title: 'Setup Biometric',
          headerBackTitle: 'Back'
        }}
      />
    </Stack.Navigator>
  );
};

export default AppNavigator;./navigation/AuthNavigator.tsx
==== ./navigation/AuthNavigator.tsx ====
import React from 'react';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import Login from '../screens/auth/Login';
import Register from '../screens/auth/Register';
import { AuthStackParamList } from '../types/navigation';

const Stack = createNativeStackNavigator<AuthStackParamList>();

const AuthNavigator: React.FC = () => {
  return (
    <Stack.Navigator
      initialRouteName="Login"
      screenOptions={{
        headerShown: false,
        animation: 'slide_from_right',
      }}
    >
      <Stack.Screen name="Login" component={Login} />
      <Stack.Screen name="Register" component={Register} />
    </Stack.Navigator>
  );
};

export default AuthNavigator;./navigation/BottomTabNavigator.tsx
==== ./navigation/BottomTabNavigator.tsx ====
import React from 'react';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import PokemonList from '../screens/main/PokemonList';
import Favorites from '../screens/main/Favorites';
import Settings from '../screens/settings/Settings';
import { MainTabParamList } from '../types/navigation';
import BottomTabBar from '../components/layout/BottomTabBar';

const Tab = createBottomTabNavigator<MainTabParamList>();

const BottomTabNavigator: React.FC = () => {
  return (
    <Tab.Navigator
      tabBar={props => <BottomTabBar {...props} />}
      screenOptions={{
        headerShown: false,
      }}
    >
      <Tab.Screen 
        name="PokemonList" 
        component={PokemonList}
        options={{ title: 'Pok√©mon' }}
      />
      <Tab.Screen 
        name="Favorites" 
        component={Favorites}
        options={{ title: 'Favorites' }}
      />
      <Tab.Screen 
        name="Settings" 
        component={Settings}
        options={{ title: 'Settings' }}
      />
    </Tab.Navigator>
  );
};

export default BottomTabNavigator;./navigation/DrawerNavigator.tsx
==== ./navigation/DrawerNavigator.tsx ====
import React from 'react';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { enableScreens } from 'react-native-screens';
import BottomTabNavigator from './BottomTabNavigator';
import Settings from '../screens/settings/Settings';
import BiometricSettings from '../screens/settings/BiometricSettings';
import LocationSettings from '../screens/settings/LocationSettings';
import { DrawerParamList } from '../types/navigation';
import DrawerContent from '../components/layout/DrawerContent';

enableScreens();

const Drawer = createDrawerNavigator<DrawerParamList>();

const DrawerNavigator: React.FC = () => {
  return (
    <Drawer.Navigator
      drawerContent={props => <DrawerContent {...props} />}
      screenOptions={{
        headerShown: true,
        headerStyle: {
          backgroundColor: '#DC0A2D',
        },
        headerTintColor: '#FFFFFF',
        headerTitleStyle: {
          fontWeight: 'bold',
        },
        drawerStyle: {
          width: 280,
        },
        drawerActiveTintColor: '#DC0A2D',
        drawerInactiveTintColor: '#333',
      }}
    >
      <Drawer.Screen 
        name="MainTabs" 
        component={BottomTabNavigator}
        options={{ 
          title: 'Pok√©mon List',
          headerTitle: 'Pok√©dex'
        }}
      />
      <Drawer.Screen 
        name="Settings" 
        component={Settings}
        options={{ title: 'Settings' }}
      />
      <Drawer.Screen 
        name="BiometricSettings" 
        component={BiometricSettings}
        options={{ title: 'Biometric Settings' }}
      />
      <Drawer.Screen 
        name="LocationSettings" 
        component={LocationSettings}
        options={{ title: 'Location Settings' }}
      />
    </Drawer.Navigator>
  );
};

export default DrawerNavigator;./navigation/TopTabNavigator.tsx
==== ./navigation/TopTabNavigator.tsx ====
import React from 'react';
import { createMaterialTopTabNavigator } from '@react-navigation/material-top-tabs';
import { AllPokemonTab, ByTypeTab, SearchTab } from '../screens/main/tabs';
import { Theme } from '../styles/themes';

export type TopTabParamList = {
  AllPokemon: undefined;
  ByType: undefined;
  Search: undefined;
};

const TopTab = createMaterialTopTabNavigator<TopTabParamList>();

const TopTabNavigator = () => {
  return (
    <TopTab.Navigator
      screenOptions={{
        tabBarActiveTintColor: Theme.colors.primary,
        tabBarInactiveTintColor: Theme.colors.text.secondary,
        tabBarIndicatorStyle: {
          backgroundColor: Theme.colors.primary,
          height: 3,
        },
        tabBarLabelStyle: {
          fontSize: Theme.typography.size.sm,
          fontFamily: Theme.typography.family.bold,
          textTransform: 'none',
        },
        tabBarStyle: {
          backgroundColor: Theme.colors.surface,
          elevation: 0,
          shadowOpacity: 0,
          borderBottomWidth: 1,
          borderBottomColor: Theme.colors.borderLight,
        },
        tabBarContentContainerStyle: {
          paddingHorizontal: Theme.spacing.md,
        },
      }}
    >
      <TopTab.Screen 
        name="AllPokemon" 
        component={AllPokemonTab}
        options={{
          title: 'All Pok√©mon'
        }}
      />
      <TopTab.Screen 
        name="ByType" 
        component={ByTypeTab}
        options={{
          title: 'By Type'
        }}
      />
      <TopTab.Screen 
        name="Search" 
        component={SearchTab}
        options={{
          title: 'Search'
        }}
      />
    </TopTab.Navigator>
  );
};

export default TopTabNavigator;./screens/auth/Login.tsx
==== ./screens/auth/Login.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  KeyboardAvoidingView,
  Platform,
  TouchableOpacity,
  Animated,
  Easing
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import Input from '../../components/common/Input';
import Button from '../../components/common/Button';
import Loading from '../../components/common/Loading';
import { Theme } from '../../styles/themes';
import { useAuth } from '../../hooks/useAuth';
import { useBiometric } from '../../hooks/useBiometric';
import { RootStackParamList, AuthStackParamList } from '../../types/navigation';

type LoginScreenNavigationProp = NativeStackNavigationProp<RootStackParamList & AuthStackParamList>;

const Login: React.FC = () => {
  const navigation = useNavigation<LoginScreenNavigationProp>();
  const { login, biometricLogin, isLoading: authLoading } = useAuth();
  const { isAvailable, isEnabled, authenticate, isLoading: biometricLoading } = useBiometric();

  const [formData, setFormData] = useState({
    email: '',
    password: '',
  });
  const [errors, setErrors] = useState({
    email: '',
    password: '',
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [fadeAnim] = useState(new Animated.Value(0));
  const [slideAnim] = useState(new Animated.Value(50));

  useEffect(() => {
    checkBiometricLogin();
    startAnimations();
  }, []);

  const startAnimations = () => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 800,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      })
    ]).start();
  };

  const checkBiometricLogin = async () => {
    if (isEnabled) {
      const success = await biometricLogin();
      if (success) {
        // Biometric login successful, navigation handled by auth hook
      }
    }
  };

  const validateForm = (): boolean => {
    const newErrors = {
      email: '',
      password: '',
    };

    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    setErrors(newErrors);
    return !newErrors.email && !newErrors.password;
  };

  const handleLogin = async () => {
    if (!validateForm()) return;

    setIsSubmitting(true);
    const success = await login(formData);

    if (success) {
      navigation.navigate('Main');
    } else {
      setErrors({
        email: 'Invalid credentials',
        password: 'Invalid credentials',
      });
    }

    setIsSubmitting(false);
  };

  const handleBiometricLogin = async () => {
    const success = await biometricLogin();
    if (!success) {
      setErrors({
        email: 'Biometric authentication failed',
        password: 'Biometric authentication failed',
      });
    }
  };

  const navigateToRegister = () => {
    navigation.navigate('Auth', { screen: 'Register' });
  };

  if (authLoading || biometricLoading) {
    return <Loading text="Loading..." type="spinner" />;
  }

  return (
    <Container safeArea={false}>
      {/* Animated Background */}
      <View style={styles.background} />
      
      {/* Floating Pokeballs */}
      <View style={[styles.floatingIcon, styles.pokeball1]}>
        <FontAwesome6 name="dragon" size={40} color={Theme.colors.primary} iconStyle='solid'/>
      </View>
      <View style={[styles.floatingIcon, styles.pokeball2]}>
        <FontAwesome6 name="dragon" size={30} color={Theme.colors.secondary} iconStyle='solid'/>
      </View>

      <KeyboardAvoidingView
        style={styles.keyboardAvoidingView}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <ScrollView
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <Animated.View 
            style={[
              styles.content,
              { 
                opacity: fadeAnim,
                transform: [{ translateY: slideAnim }]
              }
            ]}
          >
            {/* Header Section */}
            <View style={styles.header}>
              <View style={styles.logoContainer}>
                <FontAwesome6 name="dragon" size={80} color={Theme.colors.primary} iconStyle='solid'/>
              </View>
              <Text style={styles.title}>Welcome Back!</Text>
              <Text style={styles.subtitle}>Sign in to your Pokedex account</Text>
            </View>

            {/* Form Section */}
            <View style={styles.form}>
              <Input
                label="Email"
                placeholder="Enter your email"
                value={formData.email}
                onChangeText={(text) => setFormData(prev => ({ ...prev, email: text }))}
                error={errors.email}
                autoCapitalize="none"
                keyboardType="email-address"
                icon="envelope"
              />

              <Input
                label="Password"
                placeholder="Enter your password"
                value={formData.password}
                onChangeText={(text) => setFormData(prev => ({ ...prev, password: text }))}
                error={errors.password}
                secureTextEntry
                icon="lock"
              />

              <Button
                title="Sign In"
                onPress={handleLogin}
                loading={isSubmitting}
                disabled={isSubmitting}
                variant="primary"
                size="large"
                style={styles.loginButton}
                icon="right-to-bracket"
                iconPosition="right"
              />

              {isAvailable && isEnabled && (
                <Button
                  title="Sign In with Biometric"
                  onPress={handleBiometricLogin}
                  variant="outline"
                  size="large"
                  style={styles.biometricButton}
                  icon="fingerprint"
                  iconPosition="left"
                />
              )}

              <View style={styles.registerContainer}>
                <Text style={styles.registerText}>Don't have an account? </Text>
                <TouchableOpacity onPress={navigateToRegister}>
                  <Text style={styles.registerLink}>Sign Up</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Footer */}
            <View style={styles.footer}>
              <FontAwesome6 name="shield-halved" size={16} color={Theme.colors.text.secondary} iconStyle='solid' />
              <Text style={styles.footerText}>Secure authentication</Text>
            </View>
          </Animated.View>
        </ScrollView>
      </KeyboardAvoidingView>
    </Container>
  );
};

const styles = StyleSheet.create({
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: Theme.colors.background,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollView: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: Theme.spacing.xl,
  },
  content: {
    alignItems: 'center',
  },
  floatingIcon: {
    position: 'absolute',
    opacity: 0.1,
  },
  pokeball1: {
    top: 100,
    left: 30,
  },
  pokeball2: {
    bottom: 150,
    right: 40,
  },
  header: {
    alignItems: 'center',
    marginBottom: Theme.spacing.xxl,
  },
  logoContainer: {
    width: 120,
    height: 120,
    borderRadius: 60,
    backgroundColor: 'rgba(220, 10, 45, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
    borderWidth: 3,
    borderColor: Theme.colors.primary,
    ...Theme.shadows.medium,
  },
  title: {
    fontSize: Theme.typography.size.xxxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
  },
  form: {
    width: '100%',
    maxWidth: 400,
  },
  loginButton: {
    marginTop: Theme.spacing.md,
  },
  biometricButton: {
    marginTop: Theme.spacing.sm,
  },
  registerContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: Theme.spacing.xl,
    padding: Theme.spacing.md,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    borderRadius: Theme.borders.radius.medium,
  },
  registerText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
  },
  registerLink: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.primary,
  },
  footer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginTop: Theme.spacing.xxl,
    padding: Theme.spacing.md,
    backgroundColor: 'rgba(255, 255, 255, 0.6)',
    borderRadius: Theme.borders.radius.medium,
  },
  footerText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.sm,
  },
});

export default Login;./screens/auth/Register.tsx
==== ./screens/auth/Register.tsx ====
import React, { useState, useEffect } from 'react';
import { 
  View, 
  Text, 
  StyleSheet, 
  ScrollView, 
  KeyboardAvoidingView, 
  Platform,
  TouchableOpacity,
  Animated,
  Easing
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import Input from '../../components/common/Input';
import Button from '../../components/common/Button';
import { Theme } from '../../styles/themes';
import { useAuth } from '../../hooks/useAuth';
import { AuthStackParamList } from '../../types/navigation';

type RegisterScreenNavigationProp = NativeStackNavigationProp<AuthStackParamList, 'Register'>;

const Register: React.FC = () => {
  const navigation = useNavigation<RegisterScreenNavigationProp>();
  const { register, isLoading } = useAuth();

  const [formData, setFormData] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [errors, setErrors] = useState({
    username: '',
    email: '',
    password: '',
    confirmPassword: '',
  });
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [fadeAnim] = useState(new Animated.Value(0));
  const [slideAnim] = useState(new Animated.Value(50));

  useEffect(() => {
    startAnimations();
  }, []);

  const startAnimations = () => {
    Animated.parallel([
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 1000,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      }),
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 800,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      })
    ]).start();
  };

  const validateForm = (): boolean => {
    const newErrors = {
      username: '',
      email: '',
      password: '',
      confirmPassword: '',
    };

    if (!formData.username) {
      newErrors.username = 'Username is required';
    } else if (formData.username.length < 3) {
      newErrors.username = 'Username must be at least 3 characters';
    }

    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/\S+@\S+\.\S+/.test(formData.email)) {
      newErrors.email = 'Email is invalid';
    }

    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 6) {
      newErrors.password = 'Password must be at least 6 characters';
    }

    if (!formData.confirmPassword) {
      newErrors.confirmPassword = 'Please confirm your password';
    } else if (formData.password !== formData.confirmPassword) {
      newErrors.confirmPassword = 'Passwords do not match';
    }

    setErrors(newErrors);
    return !Object.values(newErrors).some(error => error !== '');
  };

  const handleRegister = async () => {
    if (!validateForm()) return;

    setIsSubmitting(true);
    const success = await register(formData);
    
    if (!success) {
      setErrors({
        ...errors,
        email: 'Registration failed. Please try again.',
      });
    }
    
    setIsSubmitting(false);
  };

  const navigateToLogin = () => {
    navigation.navigate('Login');
  };

  return (
    <Container safeArea={false}>
      {/* Background Elements */}
      <View style={styles.background} />
      
      {/* Floating Icons */}
      <View style={[styles.floatingIcon, styles.icon1]}>
        <FontAwesome6 name="user-plus" size={35} color={Theme.colors.primary}iconStyle='solid' />
      </View>
      <View style={[styles.floatingIcon, styles.icon2]}>
        <FontAwesome6 name="shield-halved" size={25} color={Theme.colors.secondary} iconStyle='solid'/>
      </View>

      <KeyboardAvoidingView
        style={styles.keyboardAvoidingView}
        behavior={Platform.OS === 'ios' ? 'padding' : 'height'}
      >
        <ScrollView 
          contentContainerStyle={styles.scrollView}
          keyboardShouldPersistTaps="handled"
        >
          <Animated.View 
            style={[
              styles.content,
              { 
                opacity: fadeAnim,
                transform: [{ translateY: slideAnim }]
              }
            ]}
          >
            {/* Header Section */}
            <View style={styles.header}>
              <View style={styles.logoContainer}>
                <FontAwesome6 name="user-plus" size={70} color={Theme.colors.primary} iconStyle='solid'/>
              </View>
              <Text style={styles.title}>Join the Adventure!</Text>
              <Text style={styles.subtitle}>Create your Pokedex account</Text>
            </View>

            {/* Form Section */}
            <View style={styles.form}>
              <Input
                label="Username"
                placeholder="Choose a username"
                value={formData.username}
                onChangeText={(text) => setFormData(prev => ({ ...prev, username: text }))}
                error={errors.username}
                autoCapitalize="none"
                icon="user"
              />

              <Input
                label="Email"
                placeholder="Enter your email"
                value={formData.email}
                onChangeText={(text) => setFormData(prev => ({ ...prev, email: text }))}
                error={errors.email}
                autoCapitalize="none"
                keyboardType="email-address"
                icon="envelope"
              />

              <Input
                label="Password"
                placeholder="Create a password"
                value={formData.password}
                onChangeText={(text) => setFormData(prev => ({ ...prev, password: text }))}
                error={errors.password}
                secureTextEntry
                icon="lock"
              />

              <Input
                label="Confirm Password"
                placeholder="Confirm your password"
                value={formData.confirmPassword}
                onChangeText={(text) => setFormData(prev => ({ ...prev, confirmPassword: text }))}
                error={errors.confirmPassword}
                secureTextEntry
                icon="lock"
              />

              <Button
                title="Create Account"
                onPress={handleRegister}
                loading={isSubmitting || isLoading}
                disabled={isSubmitting || isLoading}
                variant="success"
                size="large"
                style={styles.registerButton}
                icon="user-plus"
                iconPosition="left"
              />

              <View style={styles.loginContainer}>
                <Text style={styles.loginText}>Already have an account? </Text>
                <TouchableOpacity onPress={navigateToLogin}>
                  <Text style={styles.loginLink}>Sign In</Text>
                </TouchableOpacity>
              </View>
            </View>

            {/* Features Section */}
            <View style={styles.features}>
              <Text style={styles.featuresTitle}>Why Join Pokedex?</Text>
              <View style={styles.featureList}>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="dragon" size={20} color={Theme.colors.primary} iconStyle='solid'/>
                  <Text style={styles.featureText}>Discover all Pok√©mon</Text>
                </View>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="heart" size={20} color={Theme.colors.primary} />
                  <Text style={styles.featureText}>Save favorites</Text>
                </View>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="shield-halved" size={20} color={Theme.colors.primary}iconStyle='solid' />
                  <Text style={styles.featureText}>Secure account</Text>
                </View>
              </View>
            </View>
          </Animated.View>
        </ScrollView>
      </KeyboardAvoidingView>
    </Container>
  );
};

const styles = StyleSheet.create({
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    backgroundColor: Theme.colors.background,
  },
  keyboardAvoidingView: {
    flex: 1,
  },
  scrollView: {
    flexGrow: 1,
    justifyContent: 'center',
    padding: Theme.spacing.xl,
  },
  content: {
    alignItems: 'center',
  },
  floatingIcon: {
    position: 'absolute',
    opacity: 0.1,
  },
  icon1: {
    top: 80,
    right: 30,
  },
  icon2: {
    bottom: 120,
    left: 20,
  },
  header: {
    alignItems: 'center',
    marginBottom: Theme.spacing.xxl,
  },
  logoContainer: {
    width: 100,
    height: 100,
    borderRadius: 50,
    backgroundColor: 'rgba(40, 167, 69, 0.1)',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
    borderWidth: 3,
    borderColor: Theme.colors.success,
    ...Theme.shadows.medium,
  },
  title: {
    fontSize: Theme.typography.size.xxxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
  },
  subtitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
  },
  form: {
    width: '100%',
    maxWidth: 400,
  },
  registerButton: {
    marginTop: Theme.spacing.md,
  },
  loginContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    marginTop: Theme.spacing.xl,
    padding: Theme.spacing.md,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    borderRadius: Theme.borders.radius.medium,
  },
  loginText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
  },
  loginLink: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.primary,
  },
  features: {
    marginTop: Theme.spacing.xl,
    padding: Theme.spacing.lg,
    backgroundColor: 'rgba(255, 255, 255, 0.8)',
    borderRadius: Theme.borders.radius.large,
    width: '100%',
    maxWidth: 400,
  },
  featuresTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
    textAlign: 'center',
  },
  featureList: {
    gap: Theme.spacing.sm,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: Theme.spacing.sm,
  },
  featureText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.md,
  },
});

export default Register;./screens/main/BiometricSetupScreen.tsx
==== ./screens/main/BiometricSetupScreen.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Alert,
  Linking,
  Platform,
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import Button from '../../components/common/Button';
import Loading from '../../components/common/Loading';
import { Theme } from '../../styles/themes';
import { useBiometric } from '../../hooks/useBiometric';
import { useNavigation } from '@react-navigation/native';
import { useAuth } from '../../hooks/useAuth';

const BiometricSetupScreen: React.FC = () => {
  const navigation = useNavigation();
  const { user } = useAuth();
  const { isAvailable, biometryType, isEnabled, enableBiometric, authenticate } = useBiometric();
  
  const [loading, setLoading] = useState(false);
  const [currentStep, setCurrentStep] = useState(1);
  const [setupComplete, setSetupComplete] = useState(false);

  useEffect(() => {
    if (isEnabled) {
      setCurrentStep(3);
      setSetupComplete(true);
    }
  }, [isEnabled]);

  const getBiometricName = () => {
    switch (biometryType) {
      case 'FaceID':
        return 'Face ID';
      case 'TouchID':
      case 'Fingerprint':
        return 'Fingerprint';
      default:
        return 'Biometric';
    }
  };

  const getBiometricIcon = (): string => {
    switch (biometryType) {
      case 'FaceID':
        return 'face-smile';
      case 'TouchID':
      case 'Fingerprint':
        return 'fingerprint';
      default:
        return 'lock';
    }
  };

  const openDeviceSettings = () => {
    setLoading(true);
    
    Linking.openSettings().then(() => {
      setLoading(false);
    }).catch(() => {
      Alert.alert(
        'Device Settings',
        getSetupInstructions(),
        [
          { text: 'Cancel', style: 'cancel' },
          { text: 'OK' }
        ]
      );
      setLoading(false);
    });
  };

  const getSetupInstructions = () => {
    if (Platform.OS === 'ios') {
      if (biometryType === 'FaceID') {
        return 'Please go to:\nSettings > Face ID & Passcode > Set Up Face ID\n\nFollow the on-screen instructions to register your face.';
      } else {
        return 'Please go to:\nSettings > Touch ID & Passcode > Add a Fingerprint\n\nFollow the on-screen instructions to register your fingerprint.';
      }
    } else {
      return 'Please go to:\nSettings > Security > Fingerprint\n\nFollow the on-screen instructions to register your fingerprint.';
    }
  };

  const handleCheckSetup = async () => {
    setLoading(true);
    
    try {
      const authSuccess = await authenticate();
      
      if (authSuccess) {
        setCurrentStep(2);
        Alert.alert(
          'Success!',
          `${getBiometricName()} is working correctly.`,
          [{ text: 'Continue', onPress: () => setCurrentStep(3) }]
        );
      } else {
        Alert.alert(
          'Setup Required',
          `Please complete ${getBiometricName()} setup in your device settings first.`
        );
      }
    } catch (error) {
      Alert.alert(
        'Error',
        'Failed to verify biometric setup. Please try again.'
      );
    } finally {
      setLoading(false);
    }
  };

  const handleEnableAppBiometric = async () => {
    if (!user) {
      Alert.alert('Error', 'User not found.');
      return;
    }

    setLoading(true);
    try {
      const success = await enableBiometric(user.email, 'your-password');
      
      if (success) {
        setSetupComplete(true);
        Alert.alert(
          'Setup Complete!',
          `${getBiometricName()} has been enabled for this app. You can now use it for secure login.`,
          [{ text: 'Finish', onPress: () => navigation.goBack() }]
        );
      } else {
        Alert.alert(
          'Error',
          `Failed to enable ${getBiometricName()}. Please try again.`
        );
      }
    } catch (error) {
      Alert.alert(
        'Error',
        'An error occurred while enabling biometric authentication.'
      );
    } finally {
      setLoading(false);
    }
  };

  const renderStep1 = () => (
    <View style={styles.stepContainer}>
      <View style={styles.stepHeader}>
        <FontAwesome6 name="gear" size={32} color={Theme.colors.primary} iconStyle='solid'/>
        <Text style={styles.stepTitle}>Device Setup</Text>
      </View>
      
      <View style={styles.stepContent}>
        <View style={styles.iconContainer}>
          <FontAwesome6 name={getBiometricIcon() as any} size={80} color={Theme.colors.primary} />
        </View>

        <Text style={styles.stepDescription}>
          {`First, set up ${getBiometricName()} in your device settings.`}
        </Text>
        
        <View style={styles.instructionCard}>
          <View style={styles.instructionHeader}>
            <FontAwesome6 name="circle-info" size={20} color={Theme.colors.primary} iconStyle='solid'/>
            <Text style={styles.instructionTitle}>Setup Instructions:</Text>
          </View>
          <Text style={styles.instructionText}>
            {getSetupInstructions()}
          </Text>
        </View>

        <Button
          title="Open Device Settings"
          onPress={openDeviceSettings}
          loading={loading}
          variant="primary"
          size="large"
          style={styles.actionButton}
          icon='gear'
        />

        <Button
          title="I've Completed Device Setup"
          onPress={handleCheckSetup}
          loading={loading}
          variant="outline"
          size="large"
          style={styles.actionButton}
          icon="circle-check"
          />
      </View>
    </View>
  );

  const renderStep2 = () => (
    <View style={styles.stepContainer}>
      <View style={styles.stepHeader}>
        <FontAwesome6 name="check" size={32} color={Theme.colors.success} iconStyle='solid' />
        <Text style={styles.stepTitle}>Verification</Text>
      </View>
      
      <View style={styles.stepContent}>
        <View style={styles.iconContainer}>
          <FontAwesome6 name="circle-check" size={80} color={Theme.colors.success} />
        </View>

        <Text style={styles.stepDescription}>
          {`Great! ${getBiometricName()} is set up on your device.`}
        </Text>
        
        <View style={styles.verificationCard}>
          <FontAwesome6 name="shield" size={40} color={Theme.colors.success} iconStyle='solid'/>
          <Text style={styles.verificationText}>
            {`Your ${getBiometricName()} is working correctly.`}
          </Text>
        </View>

        <Button
          title="Continue to App Setup"
          onPress={() => setCurrentStep(3)}
          variant="primary"
          size="large"
          style={styles.actionButton}
          icon="arrow-right"
        />
      </View>
    </View>
  );

  const renderStep3 = () => (
    <View style={styles.stepContainer}>
      <View style={styles.stepHeader}>
        <FontAwesome6 name="mobile-screen-button" size={32} color={Theme.colors.primary} iconStyle='solid'/>
        <Text style={styles.stepTitle}>App Setup</Text>
      </View>
      
      <View style={styles.stepContent}>
        <View style={styles.iconContainer}>
          <FontAwesome6 name="lock" size={80} color={Theme.colors.primary} iconStyle='solid'/>
        </View>

        <Text style={styles.stepDescription}>
          {`Enable ${getBiometricName()} for secure app authentication.`}
        </Text>
        
        <View style={styles.featureList}>
          <View style={styles.featureItem}>
            <FontAwesome6 name="bolt" size={20} color={Theme.colors.success}iconStyle='solid' />
            <Text style={styles.featureText}>Quick and secure login</Text>
          </View>
          <View style={styles.featureItem}>
            <FontAwesome6 name="key" size={20} color={Theme.colors.success} iconStyle='solid'/>
            <Text style={styles.featureText}>No password needed</Text>
          </View>
          <View style={styles.featureItem}>
            <FontAwesome6 name="shield-halved" size={20} color={Theme.colors.success} iconStyle='solid'/>
            <Text style={styles.featureText}>Enhanced security</Text>
          </View>
        </View>

        <View style={styles.securityCard}>
          <FontAwesome6 name="shield" size={24} color={Theme.colors.text.secondary} iconStyle='solid'/>
          <Text style={styles.securityNote}>
            Your biometric data never leaves your device and is not shared with our servers.
          </Text>
        </View>

        <Button
          title={`Enable ${getBiometricName()}`}
          onPress={handleEnableAppBiometric}
          loading={loading}
          variant="primary"
          size="large"
          style={styles.actionButton}
          icon="lock"
        />
      </View>
    </View>
  );

  const renderProgress = () => (
    <View style={styles.progressContainer}>
      {[1, 2, 3].map((step) => (
        <View key={step} style={styles.progressStep}>
          <View style={[
            styles.progressCircle,
            currentStep >= step ? styles.progressCircleActive : styles.progressCircleInactive
          ]}>
            {currentStep > step ? (
              <FontAwesome6 name="check" size={16} color={Theme.colors.white} iconStyle='solid'/>
            ) : (
              <Text style={[
                styles.progressText,
                currentStep >= step ? styles.progressTextActive : styles.progressTextInactive
              ]}>
                {step}
              </Text>
            )}
          </View>
          {step < 3 && (
            <View style={[
              styles.progressLine,
              currentStep > step ? styles.progressLineActive : styles.progressLineInactive
            ]} />
          )}
        </View>
      ))}
    </View>
  );

  if (loading) {
    return (
      <Container>
        <Loading text="Checking setup..." />
      </Container>
    );
  }

  return (
    <Container>
      <ScrollView style={styles.container}>
        {/* Header */}
        <View style={styles.header}>
          <FontAwesome6 name={getBiometricIcon() as any} size={48} color={Theme.colors.primary} />
          <Text style={styles.title}>{getBiometricName()} Setup</Text>
          <Text style={styles.subtitle}>
            Follow these steps to set up {getBiometricName()} for secure authentication
          </Text>
        </View>

        {/* Progress Indicator */}
        {renderProgress()}

        {/* Steps */}
        {currentStep === 1 && renderStep1()}
        {currentStep === 2 && renderStep2()}
        {currentStep === 3 && renderStep3()}

        {/* Help Section */}
        <View style={styles.helpSection}>
          <View style={styles.helpHeader}>
            <FontAwesome6 name="circle-question" size={24} color={Theme.colors.text.primary} />
            <Text style={styles.helpTitle}>Need Help?</Text>
          </View>
          <View style={styles.helpItems}>
            <View style={styles.helpItem}>
              <FontAwesome6 name="mobile" size={16} color={Theme.colors.text.secondary} iconStyle='solid' />
              <Text style={styles.helpText}>Make sure your device supports {getBiometricName()}</Text>
            </View>
            <View style={styles.helpItem}>
              <FontAwesome6 name="lock" size={16} color={Theme.colors.text.secondary} iconStyle='solid' />
              <Text style={styles.helpText}>Ensure screen lock is enabled</Text>
            </View>
            <View style={styles.helpItem}>
              <FontAwesome6 name="book" size={16} color={Theme.colors.text.secondary} iconStyle='solid' />
              <Text style={styles.helpText}>Follow on-screen instructions carefully</Text>
            </View>
            <View style={styles.helpItem}>
              <FontAwesome6 name="life-ring" size={16} color={Theme.colors.text.secondary} />
                <Text style={styles.helpText}>Contact support if you encounter issues</Text>
            </View>
          </View>
        </View>
      </ScrollView>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: Theme.spacing.lg,
  },
  header: {
    alignItems: 'center',
    marginBottom: Theme.spacing.xl,
  },
  title: {
    fontSize: Theme.typography.size.xxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginVertical: Theme.spacing.sm,
  },
  subtitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    lineHeight: Theme.typography.lineHeight.md,
  },
  progressContainer: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: Theme.spacing.xl,
  },
  progressStep: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  progressCircle: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
  },
  progressCircleActive: {
    backgroundColor: Theme.colors.primary,
  },
  progressCircleInactive: {
    backgroundColor: Theme.colors.gray[200],
  },
  progressText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
  },
  progressTextActive: {
    color: Theme.colors.white,
  },
  progressTextInactive: {
    color: Theme.colors.text.secondary,
  },
  progressLine: {
    width: 60,
    height: 2,
    marginHorizontal: Theme.spacing.sm,
  },
  progressLineActive: {
    backgroundColor: Theme.colors.primary,
  },
  progressLineInactive: {
    backgroundColor: Theme.colors.gray[200],
  },
  stepContainer: {
    marginBottom: Theme.spacing.xl,
  },
  stepHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: Theme.spacing.lg,
  },
  stepTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  stepContent: {
    backgroundColor: Theme.colors.card,
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.xl,
    alignItems: 'center',
    ...Theme.shadows.small,
  },
  iconContainer: {
    marginBottom: Theme.spacing.lg,
  },
  stepDescription: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.lg,
    lineHeight: Theme.typography.lineHeight.md,
  },
  instructionCard: {
    backgroundColor: Theme.colors.primaryLight + '20',
    borderRadius: Theme.borders.radius.medium,
    padding: Theme.spacing.lg,
    marginBottom: Theme.spacing.lg,
    width: '100%',
  },
  instructionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.sm,
  },
  instructionTitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  instructionText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    lineHeight: Theme.typography.lineHeight.md,
  },
  verificationCard: {
    backgroundColor: Theme.colors.success + '20',
    borderRadius: Theme.borders.radius.medium,
    padding: Theme.spacing.xl,
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
    width: '100%',
  },
  verificationText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginTop: Theme.spacing.md,
    lineHeight: Theme.typography.lineHeight.md,
  },
  featureList: {
    marginBottom: Theme.spacing.lg,
    width: '100%',
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
  },
  featureText: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.md,
  },
  securityCard: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Theme.colors.gray[50],
    borderRadius: Theme.borders.radius.medium,
    padding: Theme.spacing.md,
    marginBottom: Theme.spacing.lg,
    width: '100%',
  },
  securityNote: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.md,
    flex: 1,
    fontStyle: 'italic',
  },
  actionButton: {
    width: '100%',
    marginBottom: Theme.spacing.md,
  },
  helpSection: {
    backgroundColor: Theme.colors.gray[50],
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.lg,
    marginTop: Theme.spacing.lg,
  },
  helpHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
  },
  helpTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  helpItems: {
    gap: Theme.spacing.sm,
  },
  helpItem: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  helpText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.sm,
    flex: 1,
  },
});

export default BiometricSetupScreen;./screens/main/Favorites.tsx
==== ./screens/main/Favorites.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  FlatList,
  Animated,
  Easing,
  TouchableOpacity,
  Alert
} from 'react-native';
import { useNavigation, useIsFocused } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import PokemonCard from '../../components/common/PokemonCard';
import Loading from '../../components/common/Loading';
import ErrorScreen from '../../components/common/ErrorScreen';
import Button from '../../components/common/Button';
import { Theme } from '../../styles/themes';
import { useFavorites } from '../../hooks/useFavorites';
import { usePokemon } from '../../hooks/usePokemon';
import { Pokemon, PokemonListItem } from '../../types/pokemon';
import { RootStackParamList } from '../../types/navigation';
import { capitalizeFirst } from '../../utils/helpers';

type FavoritesScreenNavigationProp = NativeStackNavigationProp<RootStackParamList>;

const Favorites: React.FC = () => {
  const navigation = useNavigation<FavoritesScreenNavigationProp>();
  const isFocused = useIsFocused();
  
  const { favorites, isLoading: favoritesLoading, clearFavorites, isFavorite, toggleFavorite } = useFavorites();
  const { fetchPokemonDetail } = usePokemon();
  
  const [favoritePokemon, setFavoritePokemon] = useState<Pokemon[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [bounceValue] = useState(new Animated.Value(0));
  const [fadeAnim] = useState(new Animated.Value(0));

  useEffect(() => {
    if (isFocused) {
      loadFavoritePokemon();
      startBounceAnimation();
      startFadeAnimation();
    }
  }, [favorites, isFocused]);

  const startBounceAnimation = () => {
    bounceValue.setValue(0);
    Animated.loop(
      Animated.sequence([
        Animated.timing(bounceValue, {
          toValue: 1,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(bounceValue, {
          toValue: 0,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const startFadeAnimation = () => {
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 800,
      easing: Easing.out(Easing.ease),
      useNativeDriver: true,
    }).start();
  };

  const bounce = bounceValue.interpolate({
    inputRange: [0, 1],
    outputRange: [0, -10],
  });

  const loadFavoritePokemon = async () => {
    try {
      setLoading(true);
      setError(null);

      if (favorites.length === 0) {
        setFavoritePokemon([]);
        setLoading(false);
        return;
      }

      const pokemonDetails = await Promise.all(
        favorites.map(id => fetchPokemonDetail(id))
      );

      const validPokemon = pokemonDetails.filter(
        (pokemon): pokemon is Pokemon => pokemon !== null
      );

      setFavoritePokemon(validPokemon);
    } catch (err) {
      setError('Failed to load favorite Pok√©mon');
      console.error('Error loading favorite Pok√©mon:', err);
    } finally {
      setLoading(false);
    }
  };

  const handlePokemonPress = (pokemon: Pokemon) => {
    navigation.navigate('PokemonDetail', {
      pokemonId: pokemon.id,
      pokemonName: pokemon.name,
    });
  };

  const handleToggleFavorite = async (pokemonId: number) => {
    await toggleFavorite(pokemonId);
  };

  const handleClearFavorites = () => {
    Alert.alert(
      'Clear All Favorites',
      'Are you sure you want to remove all Pok√©mon from your favorites?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Clear All',
          style: 'destructive',
          onPress: async () => {
            const success = await clearFavorites();
            if (success) {
              setFavoritePokemon([]);
            }
          },
        },
      ]
    );
  };

  const handleRetry = () => {
    loadFavoritePokemon();
  };

  const convertToPokemonListItem = (pokemon: Pokemon): PokemonListItem => ({
    name: pokemon.name,
    url: `https://pokeapi.co/api/v2/pokemon/${pokemon.id}/`,
    id: pokemon.id,
  });

  // Render loading animation
  const renderLoadingAnimation = () => (
    <Animated.View style={{ transform: [{ translateY: bounce }] }}>
      <FontAwesome6 name="heart" size={60} color={Theme.colors.primary} />
    </Animated.View>
  );

  if (favoritesLoading || loading) {
    return (
      <Container>
        <View style={styles.loadingContainer}>
          {renderLoadingAnimation()}
          <Text style={styles.loadingText}>Loading favorites...</Text>
        </View>
      </Container>
    );
  }

  if (error) {
    return (
      <Container>
        <ErrorScreen
          title="Error Loading Favorites"
          message={error}
          onRetry={handleRetry}
          retryButtonText="Try Again"
          icon="heart-crack"
        />
      </Container>
    );
  }

  if (favoritePokemon.length === 0) {
    return (
      <Container>
        <Animated.View 
          style={[
            styles.emptyContainer,
            { opacity: fadeAnim }
          ]}
        >
          <Animated.View style={{ transform: [{ translateY: bounce }] }}>
            <FontAwesome6 name="heart-crack" size={80} color={Theme.colors.gray[400]} iconStyle='solid'/>
          </Animated.View>
          <Text style={styles.emptyTitle}>No Favorite Pok√©mon</Text>
          <Text style={styles.emptyMessage}>
            Start adding Pok√©mon to your favorites by tapping the heart icon on their detail page.
          </Text>
          <Button
            title="Explore Pok√©mon"
            onPress={() => navigation.navigate('Main')}
            variant="primary"
            style={styles.exploreButton}
            icon="dragon"
            iconPosition="left"
          />
        </Animated.View>
      </Container>
    );
  }

  return (
    <Container>
      <Animated.View 
        style={[
          styles.header,
          { opacity: fadeAnim }
        ]}
      >
        <View style={styles.headerContent}>
          <View style={styles.titleContainer}>
            <FontAwesome6 name="heart" size={32} color={Theme.colors.white} />
            <Text style={styles.title}>Favorite Pok√©mon</Text>
          </View>
          <Text style={styles.subtitle}>
            {favoritePokemon.length} {favoritePokemon.length === 1 ? 'Pok√©mon' : 'Pok√©mon'} saved
          </Text>
          
          <View style={styles.actionsContainer}>
            <Button
              title="Clear All"
              onPress={handleClearFavorites}
              variant="outline"
              size="small"
              style={styles.clearButton}
              icon="trash"
              iconPosition="left"
            />
          </View>
        </View>
      </Animated.View>

      <FlatList
        data={favoritePokemon}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <PokemonCard
            pokemon={convertToPokemonListItem(item)}
            pokemonId={item.id}
            types={item.types.map(type => type.type.name)}
            onPress={() => handlePokemonPress(item)}
            isFavorite={isFavorite(item.id)}
            onToggleFavorite={() => handleToggleFavorite(item.id)}
          />
        )}
        numColumns={2}
        contentContainerStyle={styles.listContainer}
        showsVerticalScrollIndicator={false}
      />
    </Container>
  );
};

const styles = StyleSheet.create({
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  loadingText: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
    marginTop: Theme.spacing.lg,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  emptyTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
    textAlign: 'center',
  },
  emptyMessage: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.xl,
    lineHeight: Theme.typography.lineHeight.md,
  },
  exploreButton: {
    minWidth: 200,
  },
  header: {
    padding: Theme.spacing.lg,
    backgroundColor: Theme.colors.primary,
  },
  headerContent: {
    alignItems: 'center',
  },
  titleContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.sm,
  },
  title: {
    fontSize: Theme.typography.size.xxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginLeft: Theme.spacing.sm,
  },
  subtitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.9,
    marginBottom: Theme.spacing.lg,
  },
  actionsContainer: {
    flexDirection: 'row',
    gap: Theme.spacing.md,
  },
  clearButton: {
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
  },
  listContainer: {
    padding: Theme.spacing.sm,
  },
});

export default Favorites;./screens/main/NotFound.tsx
==== ./screens/main/NotFound.tsx ====
import React, { useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  Animated,
  Easing,
} from 'react-native';
import { useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import Container from '../../components/layout/Container';
import Button from '../../components/common/Button';
import { Theme } from '../../styles/themes';
import { RootStackParamList } from '../../types/navigation';

type NotFoundScreenNavigationProp = NativeStackNavigationProp<RootStackParamList>;

const NotFound: React.FC = () => {
  const navigation = useNavigation<NotFoundScreenNavigationProp>();
  const route = useRoute();
  const params = route.params as { error?: string };

  const error = params?.error || 'The page you are looking for does not exist.';
  
  const bounceValue = new Animated.Value(0);
  const fadeAnim = new Animated.Value(0);

  useEffect(() => {
    startAnimations();
  }, []);

  const startAnimations = () => {
    // Bounce animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(bounceValue, {
          toValue: 1,
          duration: 1500,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(bounceValue, {
          toValue: 0,
          duration: 1500,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();

    // Fade in animation
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 1000,
      useNativeDriver: true,
    }).start();
  };

  const bounce = bounceValue.interpolate({
    inputRange: [0, 1],
    outputRange: [0, 20],
  });

  const handleGoHome = () => {
    navigation.navigate('Main');
  };

  const handleGoBack = () => {
    navigation.goBack();
  };

  return (
    <Container>
      <Animated.View 
        style={[
          styles.container,
          { opacity: fadeAnim }
        ]}
      >
        <Animated.Text
          style={[
            styles.errorCode,
            { transform: [{ translateY: bounce }] }
          ]}
        >
          404
        </Animated.Text>
        
        <Text style={styles.title}>Page Not Found</Text>
        
        <Text style={styles.message}>
          {error}
        </Text>

        <View style={styles.buttonContainer}>
          <Button
            title="Go Home"
            onPress={handleGoHome}
            variant="primary"
            size="large"
            style={styles.button}
          />
          
          <Button
            title="Go Back"
            onPress={handleGoBack}
            variant="outline"
            size="large"
            style={styles.button}
          />
        </View>

        <Animated.Image
          style={[
            styles.pokemonImage,
            { transform: [{ translateY: bounce }] }
          ]}
        />
      </Animated.View>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  errorCode: {
    fontSize: 120,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.primary,
    marginBottom: Theme.spacing.lg,
  },
  title: {
    fontSize: Theme.typography.size.xxxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.lg,
    textAlign: 'center',
  },
  message: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.xxl,
    lineHeight: Theme.typography.lineHeight.md,
  },
  buttonContainer: {
    width: '100%',
    maxWidth: 300,
    gap: Theme.spacing.md,
  },
  button: {
    width: '100%',
  },
  pokemonImage: {
    width: 200,
    height: 200,
    marginTop: Theme.spacing.xxl,
    opacity: 0.7,
  },
});

export default NotFound;./screens/main/PokemonDetail.tsx
==== ./screens/main/PokemonDetail.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Image,
  Animated,
  Easing,
  TouchableOpacity,
} from 'react-native';
import { RouteProp, useNavigation, useRoute } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import Container from '../../components/layout/Container';
import Loading from '../../components/common/Loading';
import ErrorScreen from '../../components/common/ErrorScreen';
import Button from '../../components/common/Button';
import { Theme } from '../../styles/themes';
import { usePokemon } from '../../hooks/usePokemon';
import { useFavorites } from '../../hooks/useFavorites';
import { RootStackParamList } from '../../types/navigation';
import { capitalizeFirst, formatNumber, formatHeight, formatWeight, getTypeColor } from '../../utils/helpers';

type PokemonDetailScreenNavigationProp = NativeStackNavigationProp<RootStackParamList, 'PokemonDetail'>;
type PokemonDetailScreenRouteProp = RouteProp<RootStackParamList, 'PokemonDetail'>;

const PokemonDetail: React.FC = () => {
  const navigation = useNavigation<PokemonDetailScreenNavigationProp>();
  const route = useRoute<PokemonDetailScreenRouteProp>();
  const { pokemonId, pokemonName } = route.params;
  
  const { fetchPokemonDetail, selectedPokemon, isLoading, error } = usePokemon();
  const { isFavorite, toggleFavorite } = useFavorites();
  
  const [favorite, setFavorite] = useState(false);
  const spinValue = new Animated.Value(0);
  const fadeAnim = new Animated.Value(0);

  useEffect(() => {
    loadPokemonDetail();
    checkFavoriteStatus();
  }, [pokemonId]);

  useEffect(() => {
    if (selectedPokemon) {
      startAnimations();
    }
  }, [selectedPokemon]);

  const startAnimations = () => {
    // Spin animation for pokeball
    spinValue.setValue(0);
    Animated.loop(
      Animated.timing(spinValue, {
        toValue: 1,
        duration: 2000,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    ).start();

    // Fade in animation
    Animated.timing(fadeAnim, {
      toValue: 1,
      duration: 500,
      useNativeDriver: true,
    }).start();
  };

  const getImageUrl = () => {
    if (!selectedPokemon) return '';
    
    // Prefer official artwork, fallback to default sprite
    return selectedPokemon.sprites.other['official-artwork'].front_default ||
           selectedPokemon.sprites.front_default ||
           `https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon/${selectedPokemon.id}.png`;
  };

  const spin = spinValue.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const loadPokemonDetail = async () => {
    await fetchPokemonDetail(pokemonId);
  };

  const checkFavoriteStatus = async () => {
    const favoriteStatus = await isFavorite(pokemonId);
    setFavorite(favoriteStatus);
  };

  const handleToggleFavorite = async () => {
    const success = await toggleFavorite(pokemonId);
    if (success) {
      setFavorite(!favorite);
    }
  };

  const handleRetry = () => {
    loadPokemonDetail();
  };

  if (isLoading && !selectedPokemon) {
    return (
      <Container>
        <View style={styles.loadingContainer}>
          <Animated.Image
            style={[styles.loadingIcon, { transform: [{ rotate: spin }] }]}
          />
          <Text style={styles.loadingText}>Loading {capitalizeFirst(pokemonName)}...</Text>
        </View>
      </Container>
    );
  }

  if (error && !selectedPokemon) {
    return (
      <Container>
        <ErrorScreen
          title="Pok√©mon Not Found"
          message={error}
          onRetry={handleRetry}
          retryButtonText="Try Again"
        />
      </Container>
    );
  }

  if (!selectedPokemon) {
    return null;
  }

  const primaryType = selectedPokemon.types[0]?.type.name || 'normal';
  const primaryColor = getTypeColor(primaryType);

  return (
    <Container>
      <ScrollView 
        style={styles.container}
        showsVerticalScrollIndicator={false}
      >
        <Animated.View style={[styles.content, { opacity: fadeAnim }]}>
          {/* Header Section */}
          <View style={[styles.header, { backgroundColor: primaryColor }]}>
            <View style={styles.headerContent}>
              <View>
                <Text style={styles.number}>
                  {formatNumber(selectedPokemon.id)}
                </Text>
                <Text style={styles.name}>
                  {capitalizeFirst(selectedPokemon.name)}
                </Text>
                <View style={styles.typesContainer}>
                  {selectedPokemon.types.map((typeInfo, index) => (
                    <View
                      key={index}
                      style={[
                        styles.typeBadge,
                        { backgroundColor: 'rgba(255, 255, 255, 0.3)' },
                      ]}
                    >
                      <Text style={styles.typeText}>
                        {capitalizeFirst(typeInfo.type.name)}
                      </Text>
                    </View>
                  ))}
                </View>
              </View>
              
              <TouchableOpacity 
                style={styles.favoriteButton}
                onPress={handleToggleFavorite}
              >
                <Animated.Image
                  style={[styles.favoriteIcon, { transform: [{ rotate: spin }] }]}
                />
              </TouchableOpacity>
            </View>
          </View>

          {/* Image Section */}
          <View style={styles.imageContainer}>
            <Image
              source={{ uri: getImageUrl() }}
              style={styles.image}
              resizeMode="contain"
            />
          </View>

          {/* Stats Section */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Base Stats</Text>
            <View style={styles.statsContainer}>
              {selectedPokemon.stats.map((stat, index) => (
                <View key={index} style={styles.statRow}>
                  <Text style={styles.statName}>
                    {capitalizeFirst(stat.stat.name.replace('-', ' '))}
                  </Text>
                  <View style={styles.statBarContainer}>
                    <View
                      style={[
                        styles.statBar,
                        {
                          width: `${(stat.base_stat / 255) * 100}%`,
                          backgroundColor: primaryColor,
                        },
                      ]}
                    />
                  </View>
                  <Text style={styles.statValue}>{stat.base_stat}</Text>
                </View>
              ))}
            </View>
          </View>

          {/* Info Section */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Information</Text>
            <View style={styles.infoGrid}>
              <View style={styles.infoItem}>
                <Text style={styles.infoLabel}>Height</Text>
                <Text style={styles.infoValue}>
                  {formatHeight(selectedPokemon.height)}
                </Text>
              </View>
              <View style={styles.infoItem}>
                <Text style={styles.infoLabel}>Weight</Text>
                <Text style={styles.infoValue}>
                  {formatWeight(selectedPokemon.weight)}
                </Text>
              </View>
              <View style={styles.infoItem}>
                <Text style={styles.infoLabel}>Base Exp</Text>
                <Text style={styles.infoValue}>
                  {selectedPokemon.base_experience}
                </Text>
              </View>
            </View>
          </View>

          {/* Abilities Section */}
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Abilities</Text>
            <View style={styles.abilitiesContainer}>
              {selectedPokemon.abilities.map((ability, index) => (
                <View
                  key={index}
                  style={[
                    styles.abilityBadge,
                    { backgroundColor: primaryColor },
                  ]}
                >
                  <Text style={styles.abilityText}>
                    {capitalizeFirst(ability.ability.name.replace('-', ' '))}
                    {ability.is_hidden && ' (Hidden)'}
                  </Text>
                </View>
              ))}
            </View>
          </View>
        </Animated.View>
      </ScrollView>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  content: {
    flex: 1,
  },
  loadingContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  loadingIcon: {
    width: 60,
    height: 60,
    marginBottom: Theme.spacing.lg,
  },
  loadingText: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
  },
  header: {
    padding: Theme.spacing.xl,
    borderBottomLeftRadius: 30,
    borderBottomRightRadius: 30,
    ...Theme.shadows.medium,
  },
  headerContent: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'flex-start',
  },
  number: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
    opacity: 0.8,
  },
  name: {
    fontSize: Theme.typography.size.xxxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginVertical: Theme.spacing.sm,
  },
  typesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
  },
  typeBadge: {
    paddingHorizontal: Theme.spacing.md,
    paddingVertical: Theme.spacing.xs,
    borderRadius: Theme.borders.radius.small,
    marginRight: Theme.spacing.sm,
    marginBottom: Theme.spacing.xs,
  },
  typeText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
  },
  favoriteButton: {
    padding: Theme.spacing.sm,
  },
  favoriteIcon: {
    width: 40,
    height: 40,
  },
  imageContainer: {
    alignItems: 'center',
    marginTop: -80,
    marginBottom: Theme.spacing.lg,
  },
  image: {
    width: 200,
    height: 200,
    ...Theme.shadows.large,
  },
  section: {
    padding: Theme.spacing.lg,
    marginHorizontal: Theme.spacing.md,
    marginBottom: Theme.spacing.md,
    backgroundColor: Theme.colors.card,
    borderRadius: Theme.borders.radius.large,
    ...Theme.shadows.small,
  },
  sectionTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.lg,
  },
  statsContainer: {
    gap: Theme.spacing.md,
  },
  statRow: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'space-between',
  },
  statName: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    width: 100,
  },
  statBarContainer: {
    flex: 1,
    height: 8,
    backgroundColor: Theme.colors.gray[200],
    borderRadius: Theme.borders.radius.small,
    marginHorizontal: Theme.spacing.md,
    overflow: 'hidden',
  },
  statBar: {
    height: '100%',
    borderRadius: Theme.borders.radius.small,
  },
  statValue: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    width: 30,
    textAlign: 'right',
  },
  infoGrid: {
    flexDirection: 'row',
    justifyContent: 'space-between',
  },
  infoItem: {
    alignItems: 'center',
    flex: 1,
  },
  infoLabel: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.secondary,
    marginBottom: Theme.spacing.xs,
  },
  infoValue: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
  },
  abilitiesContainer: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    gap: Theme.spacing.sm,
  },
  abilityBadge: {
    paddingHorizontal: Theme.spacing.md,
    paddingVertical: Theme.spacing.sm,
    borderRadius: Theme.borders.radius.medium,
  },
  abilityText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
  },
});

export default PokemonDetail;./screens/main/PokemonList.tsx
==== ./screens/main/PokemonList.tsx ====
import React from 'react';
import { View, StyleSheet } from 'react-native';
import TopTabNavigator from '../../navigation/TopTabNavigator';
import Container from '../../components/layout/Container';
import { NativeStackScreenProps } from '@react-navigation/native-stack';
import { MainStackParamList } from '../../types/navigation'; // ‚úÖ Correct import
import { Theme } from '../../styles/themes';

type Props = NativeStackScreenProps<MainStackParamList, 'PokemonList'>;

const PokemonList: React.FC<Props> = () => {
  return (
    <Container safeArea={true}>
      <View style={styles.container}>
        <TopTabNavigator />
      </View>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.background,
  },
});

export default PokemonList;./screens/main/tabs/AllPokemonTab.tsx
==== ./screens/main/tabs/AllPokemonTab.tsx ====
import React, { useState, useEffect, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  RefreshControl,
  TouchableOpacity,
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import PokemonCard from '../../../components/common/PokemonCard';
import { usePokemon } from '../../../hooks/usePokemon';
import { useFavorites } from '../../../hooks/useFavorites';
import { PokemonListItem } from '../../../types/pokemon';
import { MainStackParamList } from '../../../types/navigation';
import { Theme } from '../../../styles/themes';
import ErrorScreen from '../../../components/common/ErrorScreen';
import Loading from '../../../components/common/Loading';

type AllPokemonTabNavigationProp = NativeStackNavigationProp<MainStackParamList>;

const AllPokemonTab: React.FC = () => {
  const navigation = useNavigation<AllPokemonTabNavigationProp>();
  
  const { 
    pokemonList, 
    isLoading, 
    error, 
    hasMore, 
    fetchPokemonList, 
    refreshList 
  } = usePokemon();
  
  const { isFavorite, toggleFavorite } = useFavorites();
  
  const [refreshing, setRefreshing] = useState(false);
  const [loadingMore, setLoadingMore] = useState(false);

  const loadPokemon = async (loadMore: boolean = false) => {
    if (loadMore) {
      setLoadingMore(true);
      await fetchPokemonList();
      setLoadingMore(false);
    } else {
      await refreshList();
    }
  };

  const onRefresh = useCallback(async () => {
    setRefreshing(true);
    await loadPokemon(false);
    setRefreshing(false);
  }, []);

  const handleLoadMore = () => {
    if (!loadingMore && hasMore) {
      loadPokemon(true);
    }
  };

  const handlePokemonPress = (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    navigation.navigate('PokemonDetail', { 
      pokemonId,
      pokemonName: pokemon.name 
    });
  };

  const handleFavoritePress = async (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    await toggleFavorite(pokemonId);
  };

  const renderPokemonItem = ({ item }: { item: PokemonListItem }) => {
    const pokemonId = item.id || parseInt(item.url.split('/').filter(Boolean).pop() || '0');
    const favorite = isFavorite(pokemonId);

    return (
      <View style={styles.cardContainer}>
        <PokemonCard
          pokemon={item}
          pokemonId={pokemonId}
          onPress={handlePokemonPress}
        />
        <TouchableOpacity 
          style={styles.favoriteButton}
          onPress={() => handleFavoritePress(item)}
        >
          <FontAwesome6 
            name="heart" 
            size={16} 
            color={favorite ? Theme.colors.primary : Theme.colors.text.secondary}
            iconStyle='solid'
          />
        </TouchableOpacity>
      </View>
    );
  };

  const renderFooter = () => {
    if (!loadingMore) return null;
    
    return (
      <View style={styles.footerLoader}>
        <ActivityIndicator size="small" color={Theme.colors.primary} />
        <Text style={styles.footerText}>Loading more Pok√©mon...</Text>
      </View>
    );
  };

  const renderHeader = () => (
    <View style={styles.header}>
      <FontAwesome6 name="dragon" size={48} color={Theme.colors.white} iconStyle='solid'/>
      <Text style={styles.title}>Pok√©dex</Text>
      <Text style={styles.subtitle}>
        Discover and explore all {pokemonList.length}+ Pok√©mon
      </Text>
    </View>
  );

  if (isLoading && pokemonList.length === 0) {
    return (
      <View style={styles.centerContainer}>
        <Loading text="Loading Pok√©mon..." />
      </View>
    );
  }

  if (error && pokemonList.length === 0) {
    return (
      <ErrorScreen
        title="Error Loading Pok√©mon"
        message={error}
        onRetry={() => loadPokemon(false)}
        retryButtonText="Try Again"
      />
    );
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={pokemonList}
        renderItem={renderPokemonItem}
        keyExtractor={(item) => item.name}
        numColumns={2}
        contentContainerStyle={styles.listContent}
        ListHeaderComponent={renderHeader}
        ListFooterComponent={renderFooter}
        refreshControl={
          <RefreshControl
            refreshing={refreshing}
            onRefresh={onRefresh}
            colors={[Theme.colors.primary]}
            tintColor={Theme.colors.primary}
          />
        }
        onEndReached={handleLoadMore}
        onEndReachedThreshold={0.5}
        showsVerticalScrollIndicator={false}
        columnWrapperStyle={styles.columnWrapper}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.background,
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  listContent: {
    padding: Theme.spacing.sm,
    paddingBottom: Theme.spacing.xl,
  },
  columnWrapper: {
    justifyContent: 'space-between',
    marginBottom: Theme.spacing.sm,
  },
  cardContainer: {
    flex: 1,
    margin: Theme.spacing.xs,
    maxWidth: '48%',
    position: 'relative',
  },
  favoriteButton: {
    position: 'absolute',
    top: Theme.spacing.sm,
    right: Theme.spacing.sm,
    backgroundColor: Theme.colors.white,
    borderRadius: Theme.borders.radius.round,
    padding: Theme.spacing.xs,
    ...Theme.shadows.small,
  },
  header: {
    padding: Theme.spacing.lg,
    alignItems: 'center',
    backgroundColor: Theme.colors.primary,
    borderRadius: Theme.borders.radius.large,
    margin: Theme.spacing.sm,
    marginBottom: Theme.spacing.lg,
    ...Theme.shadows.medium,
  },
  title: {
    fontSize: Theme.typography.size.xxxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginVertical: Theme.spacing.sm,
  },
  subtitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    textAlign: 'center',
    opacity: 0.9,
  },
  footerLoader: {
    flexDirection: 'row',
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.lg,
  },
  footerText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.sm,
  },
});

export default AllPokemonTab;./screens/main/tabs/ByTypeTab.tsx
==== ./screens/main/tabs/ByTypeTab.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  ActivityIndicator,
  TouchableOpacity,
  ScrollView,
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import PokemonCard from '../../../components/common/PokemonCard';
import { usePokemon } from '../../../hooks/usePokemon';
import { useFavorites } from '../../../hooks/useFavorites';
import { PokemonListItem } from '../../../types/pokemon';
import { MainStackParamList } from '../../../types/navigation';
import { Theme } from '../../../styles/themes';
import { getTypeColor, capitalizeFirst } from '../../../utils/helpers';
import Loading from '../../../components/common/Loading';
import ErrorScreen from '../../../components/common/ErrorScreen';

type ByTypeTabNavigationProp = NativeStackNavigationProp<MainStackParamList>;

const ByTypeTab: React.FC = () => {
  const navigation = useNavigation<ByTypeTabNavigationProp>();
  
  const { pokemonList, isLoading, error } = usePokemon();
  const { isFavorite, toggleFavorite } = useFavorites();
  
  const [selectedType, setSelectedType] = useState<string>('all');
  const [filteredPokemon, setFilteredPokemon] = useState<PokemonListItem[]>([]);
  
  const [typeLoading, setTypeLoading] = useState(false);

  // Filter Pok√©mon by type (this is a simplified version)
  // In a real app, you'd fetch from https://pokeapi.co/api/v2/type/{type}
  useEffect(() => {
    if (selectedType === 'all') {
      setFilteredPokemon(pokemonList);
    } else {
      setTypeLoading(true);
      // Simulate API call delay
      setTimeout(() => {
        const filtered = pokemonList.filter(pokemon => 
          Math.random() > 0.7 // Random filter for demo
        );
        setFilteredPokemon(filtered);
        setTypeLoading(false);
      }, 500);
    }
  }, [selectedType, pokemonList]);

  const handlePokemonPress = (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    navigation.navigate('PokemonDetail', { 
      pokemonId,
      pokemonName: pokemon.name 
    });
  };

  const handleFavoritePress = async (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    await toggleFavorite(pokemonId);
  };

  const renderTypeItem = (type: string) => (
    <TouchableOpacity
      key={type}
      style={[
        styles.typeButton,
        selectedType === type && styles.typeButtonSelected,
        { 
          backgroundColor: type === 'all' 
            ? Theme.colors.primary 
            : getTypeColor(type)
        }
      ]}
      onPress={() => setSelectedType(type)}
    >
      <Text style={[
        styles.typeText,
        selectedType === type && styles.typeTextSelected
      ]}>
        {type === 'all' ? 'All' : capitalizeFirst(type)}
      </Text>
    </TouchableOpacity>
  );

  const renderPokemonItem = ({ item }: { item: PokemonListItem }) => {
    const pokemonId = item.id || parseInt(item.url.split('/').filter(Boolean).pop() || '0');
    const favorite = isFavorite(pokemonId);

    return (
      <View style={styles.cardContainer}>
        <PokemonCard
          pokemon={item}
          pokemonId={pokemonId}
          onPress={handlePokemonPress}
        />
        <TouchableOpacity 
          style={styles.favoriteButton}
          onPress={() => handleFavoritePress(item)}
        >
          <FontAwesome6 
            name="heart" 
            size={16} 
            color={favorite ? Theme.colors.primary : Theme.colors.text.secondary}
            iconStyle='solid'
          />
        </TouchableOpacity>
      </View>
    );
  };

  if (isLoading && pokemonList.length === 0) {
    return (
      <View style={styles.centerContainer}>
        <Loading text="Loading Pok√©mon..." />
      </View>
    );
  }

  if (error && pokemonList.length === 0) {
    return (
      <ErrorScreen
        title="Error Loading Pok√©mon"
        message={error}
        onRetry={() => {}}
        retryButtonText="Try Again"
      />
    );
  }

  return (
    <View style={styles.container}>
      {/* Type Selection */}
      <View style={styles.typeSection}>
        <View style={styles.sectionHeader}>
          <FontAwesome6 name="filter" size={20} color={Theme.colors.text.primary} iconStyle='solid' />
          <Text style={styles.sectionTitle}>Filter by Type</Text>
        </View>
        <ScrollView 
          horizontal 
          showsHorizontalScrollIndicator={false}
          contentContainerStyle={styles.typeList}
        >
          {renderTypeItem('all')}
          {POKEMON_TYPES.map(renderTypeItem)}
        </ScrollView>
      </View>

      {/* Pok√©mon Grid */}
      <View style={styles.pokemonSection}>
        <View style={styles.sectionHeader}>
          <FontAwesome6 name="dragon" size={20} color={Theme.colors.text.primary}  iconStyle='solid'/>
          <Text style={styles.sectionTitle}>
            {selectedType === 'all' 
              ? 'All Pok√©mon' 
              : `${capitalizeFirst(selectedType)} Pok√©mon`
            } ({filteredPokemon.length})
          </Text>
        </View>

        {typeLoading ? (
          <View style={styles.centerContainer}>
            <ActivityIndicator size="large" color={Theme.colors.primary} />
            <Text style={styles.loadingText}>Filtering Pok√©mon...</Text>
          </View>
        ) : filteredPokemon.length === 0 ? (
          <View style={styles.emptyContainer}>
            <FontAwesome6 name="magnifying-glass" size={48} color={Theme.colors.text.secondary}  iconStyle='solid'/>
            <Text style={styles.emptyText}>
              No Pok√©mon found for this type.
            </Text>
          </View>
        ) : (
          <FlatList
            data={filteredPokemon}
            renderItem={renderPokemonItem}
            keyExtractor={(item) => item.name}
            numColumns={2}
            contentContainerStyle={styles.listContent}
            showsVerticalScrollIndicator={false}
            columnWrapperStyle={styles.columnWrapper}
          />
        )}
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.background,
  },
  centerContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  typeSection: {
    backgroundColor: Theme.colors.surface,
    padding: Theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
  },
  sectionHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
  },
  sectionTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  typeList: {
    paddingRight: Theme.spacing.md,
  },
  typeButton: {
    paddingHorizontal: Theme.spacing.lg,
    paddingVertical: Theme.spacing.sm,
    borderRadius: Theme.borders.radius.round,
    marginRight: Theme.spacing.sm,
    minWidth: 80,
    alignItems: 'center',
    justifyContent: 'center',
  },
  typeButtonSelected: {
    borderWidth: 2,
    borderColor: Theme.colors.white,
    ...Theme.shadows.medium,
  },
  typeText: {
    color: Theme.colors.white,
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.bold,
    textTransform: 'capitalize',
  },
  typeTextSelected: {
    color: Theme.colors.white,
  },
  pokemonSection: {
    flex: 1,
    padding: Theme.spacing.md,
  },
  listContent: {
    paddingBottom: Theme.spacing.xl,
  },
  columnWrapper: {
    justifyContent: 'space-between',
    marginBottom: Theme.spacing.sm,
  },
  cardContainer: {
    flex: 1,
    margin: Theme.spacing.xs,
    maxWidth: '48%',
    position: 'relative',
  },
  favoriteButton: {
    position: 'absolute',
    top: Theme.spacing.sm,
    right: Theme.spacing.sm,
    backgroundColor: Theme.colors.white,
    borderRadius: Theme.borders.radius.round,
    padding: Theme.spacing.xs,
    ...Theme.shadows.small,
  },
  loadingText: {
    marginTop: Theme.spacing.md,
    fontSize: Theme.typography.size.md,
    color: Theme.colors.text.secondary,
  },
  emptyContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  emptyText: {
    fontSize: Theme.typography.size.md,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginTop: Theme.spacing.md,
  },
});

export default ByTypeTab;./screens/main/tabs/index.tsx
==== ./screens/main/tabs/index.tsx ====
export { default as AllPokemonTab } from './AllPokemonTab';
export { default as ByTypeTab } from './ByTypeTab';
export { default as SearchTab } from './SearchTab';./screens/main/tabs/SearchTab.tsx
==== ./screens/main/tabs/SearchTab.tsx ====
import React, { useState, useCallback } from 'react';
import {
  View,
  Text,
  FlatList,
  StyleSheet,
  TextInput,
  TouchableOpacity,
  Keyboard,
} from 'react-native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import PokemonCard from '../../../components/common/PokemonCard';
import { usePokemon } from '../../../hooks/usePokemon';
import { useFavorites } from '../../../hooks/useFavorites';
import { PokemonListItem } from '../../../types/pokemon';
import { MainStackParamList } from '../../../types/navigation';
import { Theme } from '../../../styles/themes';
import { capitalizeFirst } from '../../../utils/helpers';

type SearchTabNavigationProp = NativeStackNavigationProp<MainStackParamList>;

const SearchTab: React.FC = () => {
  const navigation = useNavigation<SearchTabNavigationProp>();
  const { pokemonList } = usePokemon();
  const { isFavorite, toggleFavorite } = useFavorites();
  
  const [searchQuery, setSearchQuery] = useState('');
  const [searchResults, setSearchResults] = useState<PokemonListItem[]>([]);

  const handleSearch = useCallback((query: string) => {
    setSearchQuery(query);
    
    if (!query.trim()) {
      setSearchResults([]);
      return;
    }

    const filtered = pokemonList.filter(pokemon =>
      pokemon.name.toLowerCase().includes(query.toLowerCase()) ||
      pokemon.id?.toString().includes(query)
    );
    
    setSearchResults(filtered);
  }, [pokemonList]);

  const clearSearch = () => {
    setSearchQuery('');
    setSearchResults([]);
    Keyboard.dismiss();
  };

  const handlePokemonPress = (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    navigation.navigate('PokemonDetail', { 
      pokemonId,
      pokemonName: pokemon.name 
    });
  };

  const handleFavoritePress = async (pokemon: PokemonListItem) => {
    const pokemonId = pokemon.id || parseInt(pokemon.url.split('/').filter(Boolean).pop() || '0');
    await toggleFavorite(pokemonId);
  };

  const renderPokemonItem = ({ item }: { item: PokemonListItem }) => {
    const pokemonId = item.id || parseInt(item.url.split('/').filter(Boolean).pop() || '0');
    const favorite = isFavorite(pokemonId);

    return (
      <View style={styles.cardContainer}>
        <PokemonCard
          pokemon={item}
          pokemonId={pokemonId}
          onPress={handlePokemonPress}
        />
        <TouchableOpacity 
          style={styles.favoriteButton}
          onPress={() => handleFavoritePress(item)}
        >
          <FontAwesome6 
            name="heart" 
            size={16} 
            color={favorite ? Theme.colors.primary : Theme.colors.text.secondary}
            iconStyle='solid'
          />
        </TouchableOpacity>
      </View>
    );
  };

  return (
    <View style={styles.container}>
      {/* Search Bar */}
      <View style={styles.searchSection}>
        <View style={styles.searchContainer}>
          <FontAwesome6 
            name="magnifying-glass" 
            size={16} 
            color={Theme.colors.text.secondary}
            iconStyle='solid'
          />
          <TextInput
            style={styles.searchInput}
            placeholder="Search Pok√©mon by name or ID..."
            placeholderTextColor={Theme.colors.text.secondary}
            value={searchQuery}
            onChangeText={handleSearch}
            returnKeyType="search"
            autoCorrect={false}
            autoCapitalize="none"
          />
          {searchQuery.length > 0 && (
            <TouchableOpacity onPress={clearSearch} style={styles.clearButton}>
              <FontAwesome6 
                name="xmark" 
                size={16} 
                color={Theme.colors.text.secondary}
                iconStyle='solid'
              />
            </TouchableOpacity>
          )}
        </View>
      </View>

      {/* Search Results */}
      {searchQuery && (
        <View style={styles.resultsSection}>
          <View style={styles.resultsHeader}>
            <FontAwesome6 name="list" size={20} color={Theme.colors.text.primary} iconStyle='solid'/>
            <Text style={styles.resultsTitle}>
              {searchResults.length > 0 
                ? `Found ${searchResults.length} Pok√©mon` 
                : 'No Pok√©mon found'
              }
            </Text>
          </View>

          {searchResults.length > 0 ? (
            <FlatList
              data={searchResults}
              renderItem={renderPokemonItem}
              keyExtractor={(item) => item.name}
              numColumns={2}
              contentContainerStyle={styles.listContent}
              showsVerticalScrollIndicator={false}
              columnWrapperStyle={styles.columnWrapper}
              keyboardShouldPersistTaps="handled"
            />
          ) : (
            <View style={styles.noResults}>
              <FontAwesome6 
                name="magnifying-glass" 
                size={48} 
                color={Theme.colors.text.secondary}
                iconStyle='solid'
              />
              <Text style={styles.noResultsText}>
                No Pok√©mon found for "{searchQuery}"
              </Text>
              <Text style={styles.noResultsHint}>
                Try searching by name or Pok√©mon ID
              </Text>
            </View>
          )}
        </View>
      )}

      {/* Recent Searches or Popular Pok√©mon when no search */}
      {!searchQuery && (
        <View style={styles.initialSection}>
          <FontAwesome6 name="dollar-sign" size={64} color={Theme.colors.primary} iconStyle='solid'/>
          <Text style={styles.initialTitle}>Search Pok√©mon</Text>
          <Text style={styles.initialSubtitle}>
            Find Pok√©mon by name or ID number
          </Text>
          
          <View style={styles.suggestions}>
            <View style={styles.suggestionsHeader}>
              <FontAwesome6 name="lightbulb" size={20} color={Theme.colors.text.primary} />
              <Text style={styles.suggestionsTitle}>Try searching for:</Text>
            </View>
            <View style={styles.suggestionList}>
              {['Pikachu', 'Charizard', 'Bulbasaur', '25', '150', '6'].map((suggestion) => (
                <TouchableOpacity
                  key={suggestion}
                  style={styles.suggestionButton}
                  onPress={() => setSearchQuery(suggestion)}
                >
                  <Text style={styles.suggestionText}>{suggestion}</Text>
                </TouchableOpacity>
              ))}
            </View>
          </View>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: Theme.colors.background,
  },
  searchSection: {
    backgroundColor: Theme.colors.surface,
    padding: Theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
  },
  searchContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: Theme.colors.gray[100],
    borderRadius: Theme.borders.radius.large,
    paddingHorizontal: Theme.spacing.md,
    paddingVertical: Theme.spacing.sm,
  },
  searchInput: {
    flex: 1,
    fontSize: Theme.typography.size.md,
    color: Theme.colors.text.primary,
    fontFamily: Theme.typography.family.regular,
    marginLeft: Theme.spacing.sm,
    marginRight: Theme.spacing.sm,
  },
  clearButton: {
    padding: Theme.spacing.xs,
  },
  resultsSection: {
    flex: 1,
    padding: Theme.spacing.md,
  },
  resultsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
  },
  resultsTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  listContent: {
    paddingBottom: Theme.spacing.xl,
  },
  columnWrapper: {
    justifyContent: 'space-between',
    marginBottom: Theme.spacing.sm,
  },
  cardContainer: {
    flex: 1,
    margin: Theme.spacing.xs,
    maxWidth: '48%',
    position: 'relative',
  },
  favoriteButton: {
    position: 'absolute',
    top: Theme.spacing.sm,
    right: Theme.spacing.sm,
    backgroundColor: Theme.colors.white,
    borderRadius: Theme.borders.radius.round,
    padding: Theme.spacing.xs,
    ...Theme.shadows.small,
  },
  noResults: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  noResultsText: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginTop: Theme.spacing.lg,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
  },
  noResultsHint: {
    fontSize: Theme.typography.size.md,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
  },
  initialSection: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.xl,
  },
  initialTitle: {
    fontSize: Theme.typography.size.xxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginTop: Theme.spacing.lg,
    marginBottom: Theme.spacing.sm,
  },
  initialSubtitle: {
    fontSize: Theme.typography.size.md,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.xl,
  },
  suggestions: {
    width: '100%',
    maxWidth: 300,
  },
  suggestionsHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    justifyContent: 'center',
    marginBottom: Theme.spacing.md,
  },
  suggestionsTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  suggestionList: {
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'center',
    gap: Theme.spacing.sm,
  },
  suggestionButton: {
    backgroundColor: Theme.colors.primary,
    paddingHorizontal: Theme.spacing.lg,
    paddingVertical: Theme.spacing.sm,
    borderRadius: Theme.borders.radius.round,
  },
  suggestionText: {
    color: Theme.colors.white,
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
  },
});

export default SearchTab;./screens/settings/BiometricSettings.tsx
==== ./screens/settings/BiometricSettings.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Alert,
  Animated,
  Easing,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import Button from '../../components/common/Button';
import Loading from '../../components/common/Loading';
import { Theme } from '../../styles/themes';
import { useBiometric } from '../../hooks/useBiometric';
import { useAuth } from '../../hooks/useAuth';

const BiometricSettings: React.FC = () => {
  const navigation = useNavigation();
  const { 
    isAvailable, 
    biometryType, 
    isEnabled, 
    enableBiometric, 
    disableBiometric, 
    isLoading,
    authenticate 
  } = useBiometric();
  const { user } = useAuth();
  
  const [processing, setProcessing] = useState(false);
  const pulseValue = new Animated.Value(1);

  useEffect(() => {
    if (isEnabled) {
      startPulseAnimation();
    } else {
      pulseValue.stopAnimation();
      pulseValue.setValue(1);
    }
  }, [isEnabled]);

  const startPulseAnimation = () => {
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseValue, {
          toValue: 1.1,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(pulseValue, {
          toValue: 1,
          duration: 1000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const getBiometricName = () => {
    switch (biometryType) {
      case 'FaceID':
        return 'Face ID';
      case 'TouchID':
      case 'Fingerprint':
        return 'Fingerprint';
      default:
        return 'Biometric';
    }
  };

  const getBiometricIconName = (): string => {
    switch (biometryType) {
      case 'FaceID':
        return 'face-smile';
      case 'TouchID':
      case 'Fingerprint':
        return 'fingerprint';
      default:
        return 'lock';
    }
  };

  const handleOpenSetupScreen = () => {
    navigation.navigate('BiometricSetup' as never);
  };

  const handleEnableBiometric = async () => {
    if (!user) {
      Alert.alert('Error', 'User not found. Please login again.');
      return;
    }

    setProcessing(true);
    try {
      // First authenticate with biometric to ensure it's set up
      const authSuccess = await authenticate();
      
      if (!authSuccess) {
        Alert.alert(
          'Authentication Required',
          'Please authenticate with your biometric to enable it for the app.',
          [{ text: 'OK' }]
        );
        setProcessing(false);
        return;
      }

      // If authentication successful, enable biometric for the app
      const success = await enableBiometric(user.email, 'your-password-here');
      
      if (success) {
        Alert.alert(
          'Success',
          `${getBiometricName()} has been enabled successfully. You can now use it to login to the app.`
        );
      } else {
        Alert.alert(
          'Error',
          `Failed to enable ${getBiometricName()}. Please try again.`
        );
      }
    } catch (error) {
      console.error('Error enabling biometric:', error);
      Alert.alert(
        'Error',
        'An error occurred while enabling biometric authentication. Please make sure your biometric is set up in device settings.'
      );
    } finally {
      setProcessing(false);
    }
  };

  const handleDisableBiometric = async () => {
    Alert.alert(
      'Disable Biometric Authentication',
      `Are you sure you want to disable ${getBiometricName()}? You will need to use your password to login.`,
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Disable',
          style: 'destructive',
          onPress: async () => {
            setProcessing(true);
            try {
              const success = await disableBiometric();
              
              if (success) {
                Alert.alert(
                  'Success',
                  `${getBiometricName()} has been disabled.`
                );
              } else {
                Alert.alert(
                  'Error',
                  `Failed to disable ${getBiometricName()}. Please try again.`
                );
              }
            } catch (error) {
              Alert.alert('Error', 'An error occurred while disabling biometric.');
            } finally {
              setProcessing(false);
            }
          },
        },
      ]
    );
  };

  const handleTestBiometric = async () => {
    try {
      const success = await authenticate();
      
      if (success) {
        Alert.alert(
          'Success',
          `${getBiometricName()} authentication successful!`
        );
      } else {
        Alert.alert(
          'Failed',
          `${getBiometricName()} authentication failed. Please try again.`
        );
      }
    } catch (error) {
      Alert.alert('Error', 'An error occurred during authentication.');
    }
  };

  if (isLoading) {
    return (
      <Container>
        <Loading text="Loading biometric settings..." />
      </Container>
    );
  }

return (
    <Container>
      <ScrollView style={styles.container}>
        {/* Status Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Biometric Status</Text>
          <View style={styles.card}>
            <Animated.View 
              style={[
                styles.statusIcon,
                { 
                  transform: [{ scale: pulseValue }],
                  backgroundColor: isEnabled ? Theme.colors.primaryLight : Theme.colors.gray[200]
                }
              ]}
            >
              <FontAwesome6 
                name={getBiometricIconName() as any} 
                size={40} 
                color={isEnabled ? Theme.colors.primary : Theme.colors.text.secondary} 
              />
            </Animated.View>
            
            <Text style={styles.statusTitle}>
              {isAvailable ? getBiometricName() : 'Not Available'}
            </Text>
            
            <Text style={styles.statusDescription}>
              {isAvailable
                ? isEnabled
                  ? `${getBiometricName()} is currently enabled for authentication.`
                  : `${getBiometricName()} is available but not enabled. Tap "Setup" to configure.`
                : 'Your device does not support biometric authentication or it is not set up.'}
            </Text>

            <View style={[
              styles.statusBadge,
              { 
                backgroundColor: isEnabled 
                  ? (Theme.colors.success || '#22c55e') + '20'
                  : (Theme.colors.warning || '#f59e0b') + '20'
              }
            ]}>
              <FontAwesome6 
                name={isEnabled ? "circle-check" : "circle-xmark"} 
                size={16} 
                color={isEnabled 
                  ? Theme.colors.success || '#22c55e'
                  : Theme.colors.warning || '#f59e0b'
                } 
                style={styles.badgeIcon}
              />
              <Text style={[
                styles.statusBadgeText,
                { 
                  color: isEnabled 
                    ? Theme.colors.success || '#22c55e'
                    : Theme.colors.warning || '#f59e0b'
                }
              ]}>
                {isEnabled ? 'ENABLED' : 'DISABLED'}
              </Text>
            </View>
          </View>
        </View>

        {/* Setup Section - Show only if biometric is available but not enabled */}
        {isAvailable && !isEnabled && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Setup Required</Text>
            <View style={styles.card}>
              <View style={styles.setupHeader}>
                <FontAwesome6 name="gear" size={24} color={Theme.colors.primary} iconStyle='solid'/>
                <Text style={styles.setupTitle}>Complete Setup</Text>
              </View>
              
              <Text style={styles.registrationDescription}>
                {`To use ${getBiometricName()}, you need to complete the setup process.`}
              </Text>
              
              <View style={styles.featureList}>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="circle-check" size={16} color={Theme.colors.success} />
                  <Text style={styles.featureText}>Device configuration</Text>
                </View>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="circle-check" size={16} color={Theme.colors.success} />
                  <Text style={styles.featureText}>App integration</Text>
                </View>
                <View style={styles.featureItem}>
                  <FontAwesome6 name="circle-check" size={16} color={Theme.colors.success} />
                  <Text style={styles.featureText}>Security setup</Text>
                </View>
              </View>

              <Button
                title={`Start ${getBiometricName()} Setup`}
                onPress={handleOpenSetupScreen}
                variant="primary"
                size="large"
                style={styles.setupButton}
                icon="arrow-right"
              />
            </View>
          </View>
        )}

        {/* Actions Section */}
        {isAvailable && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Authentication Actions</Text>
            <View style={styles.card}>
              {!isEnabled ? (
                <View style={styles.enableSection}>
                  <Text style={styles.enableDescription}>
                    {`Enable ${getBiometricName()} to use it for quick and secure login to the app.`}
                  </Text>
                  <Button
                    title={`Enable ${getBiometricName()}`}
                    onPress={handleEnableBiometric}
                    loading={processing}
                    disabled={processing}
                    variant="primary"
                    size="large"
                    style={styles.actionButton}
                    icon="lock"
                  />
                </View>
              ) : (
                <>
                  <Text style={styles.enableDescription}>
                    {`${getBiometricName()} is enabled. You can test it or disable it below.`}
                  </Text>
                  <Button
                    title={`Test ${getBiometricName()}`}
                    onPress={handleTestBiometric}
                    variant="outline"
                    size="large"
                    style={styles.actionButton}
                    icon="check"
                  />
                  
                  <Button
                    title={`Disable ${getBiometricName()}`}
                    onPress={handleDisableBiometric}
                    loading={processing}
                    disabled={processing}
                    variant="danger"
                    size="large"
                    style={styles.actionButton}
                    icon="lock-open"
                  />
                </>
              )}
            </View>
          </View>
        )}

        {/* Information Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Information</Text>
          <View style={styles.card}>
            <View style={styles.infoItem}>
              <View style={styles.infoLabelContainer}>
                <FontAwesome6 name="fingerprint" size={16} color={Theme.colors.text.secondary} iconStyle='solid'/>
                <Text style={styles.infoLabel}>Biometric Type</Text>
              </View>
              <Text style={styles.infoValue}>
                {isAvailable ? getBiometricName() : 'Not Available'}
              </Text>
            </View>
            
            <View style={styles.infoItem}>
              <View style={styles.infoLabelContainer}>
                <FontAwesome6 name="power-off" size={16} color={Theme.colors.text.secondary}iconStyle='solid' />
                <Text style={styles.infoLabel}>Status</Text>
              </View>
              <View style={styles.statusValue}>
                <FontAwesome6 
                  name={isEnabled ? "circle-check" : "circle-xmark"} 
                  size={16} 
                  color={isEnabled 
                    ? Theme.colors.success || '#22c55e'
                    : Theme.colors.warning || '#f59e0b'
                  } 
                />
                <Text style={[
                  styles.infoValue,
                  { 
                    color: isEnabled 
                      ? Theme.colors.success || '#22c55e'
                      : Theme.colors.warning || '#f59e0b',
                    marginLeft: 4
                  }
                ]}>
                  {isEnabled ? 'Enabled' : 'Disabled'}
                </Text>
              </View>
            </View>
            
            <View style={styles.infoItem}>
              <View style={styles.infoLabelContainer}>
                <FontAwesome6 name="mobile" size={16} color={Theme.colors.text.secondary} iconStyle='solid'/>
                <Text style={styles.infoLabel}>Device Support</Text>
              </View>
              <Text style={styles.infoValue}>
                {isAvailable ? 'Supported' : 'Not Supported'}
              </Text>
            </View>

            <View style={styles.infoItem}>
              <View style={styles.infoLabelContainer}>
                <FontAwesome6 name="shield-halved" size={16} color={Theme.colors.text.secondary}iconStyle='solid' />
                <Text style={styles.infoLabel}>Security Level</Text>
              </View>
              <Text style={[styles.infoValue, { color: Theme.colors.success }]}>
                High
              </Text>
            </View>
          </View>
        </View>

        {/* Help Section */}
        {!isAvailable && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Help</Text>
            <View style={styles.card}>
              <View style={styles.helpHeader}>
                <FontAwesome6 name="circle-question" size={24} color={Theme.colors.text.primary} iconStyle='solid'/>
                <Text style={styles.helpTitle}>Setup Instructions</Text>
              </View>
              <View style={styles.helpItems}>
                <View style={styles.helpItem}>
                  <FontAwesome6 name="mobile" size={16} color={Theme.colors.text.secondary} iconStyle='solid'/>
                  <Text style={styles.helpText}>Ensure your device supports {getBiometricName()}</Text>
                </View>
                <View style={styles.helpItem}>
                  <FontAwesome6 name="gear" size={16} color={Theme.colors.text.secondary} iconStyle='solid'/>
                  <Text style={styles.helpText}>Set up {getBiometricName()} in device settings</Text>
                </View>
                <View style={styles.helpItem}>
                  <FontAwesome6 name="lock" size={16} color={Theme.colors.text.secondary}iconStyle='solid' />
                  <Text style={styles.helpText}>Enable screen lock security</Text>
                </View>
                <View style={styles.helpItem}>
                  <FontAwesome6 name="user-shield" size={16} color={Theme.colors.text.secondary}iconStyle='solid' />
                  <Text style={styles.helpText}>Grant permission to this app</Text>
                </View>
              </View>
              <View style={styles.securityNote}>
                <FontAwesome6 name="shield" size={16} color={Theme.colors.text.secondary} iconStyle='solid' />
                <Text style={styles.securityText}>
                  Biometric data is stored securely on your device and is never shared with our servers.
                </Text>
              </View>
            </View>
          </View>
        )}
      </ScrollView>
    </Container>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: Theme.spacing.lg,
  },
  section: {
    marginBottom: Theme.spacing.xl,
  },
  sectionTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
  },
  card: {
    backgroundColor: Theme.colors.card,
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.xl,
    alignItems: 'center',
    ...Theme.shadows.small,
  },
  statusIcon: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
  },
  statusTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
  },
  statusDescription: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.lg,
    lineHeight: Theme.typography.lineHeight.md,
  },
  statusBadge: {
    flexDirection: 'row',
    alignItems: 'center',
    paddingHorizontal: Theme.spacing.md,
    paddingVertical: Theme.spacing.xs,
    borderRadius: Theme.borders.radius.small,
  },
  badgeIcon: {
    marginRight: Theme.spacing.xs,
  },
  statusBadgeText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.bold,
  },
  setupHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
  },
  setupTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  registrationDescription: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.lg,
    lineHeight: Theme.typography.lineHeight.md,
  },
  featureList: {
    width: '100%',
    marginBottom: Theme.spacing.lg,
  },
  featureItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.sm,
  },
  featureText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  setupButton: {
    width: '100%',
  },
  actionButton: {
    width: '100%',
    marginBottom: Theme.spacing.md,
  },
  enableSection: {
    width: '100%',
    alignItems: 'center',
  },
  enableDescription: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.lg,
    lineHeight: Theme.typography.lineHeight.md,
  },
  infoItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: Theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
    width: '100%',
  },
  infoLabelContainer: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoLabel: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  statusValue: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  infoValue: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
  },
  helpHeader: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.md,
    width: '100%',
  },
  helpTitle: {
    fontSize: Theme.typography.size.lg,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginLeft: Theme.spacing.sm,
  },
  helpItems: {
    width: '100%',
    marginBottom: Theme.spacing.lg,
  },
  helpItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.sm,
  },
  helpText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.sm,
    flex: 1,
  },
  securityNote: {
    flexDirection: 'row',
    alignItems: 'flex-start',
    backgroundColor: Theme.colors.gray[50],
    borderRadius: Theme.borders.radius.medium,
    padding: Theme.spacing.md,
    width: '100%',
  },
  securityText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    marginLeft: Theme.spacing.sm,
    flex: 1,
    fontStyle: 'italic',
  },
});

export default BiometricSettings;./screens/settings/LocationSettings.tsx
==== ./screens/settings/LocationSettings.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Alert,
  Animated,
  Easing,
} from 'react-native';
import Container from '../../components/layout/Container';
import Button from '../../components/common/Button';
import Loading from '../../components/common/Loading';
import { Theme } from '../../styles/themes';
import { useLocation } from '../../hooks/useLocation';

const LocationSettings: React.FC = () => {
  const { 
    currentLocation, 
    currentAddress, 
    isLoading, 
    error, 
    getCurrentLocation, 
    clearLocation 
  } = useLocation();
  
  const [updatingLocation, setUpdatingLocation] = useState(false);
  const pulseValue = new Animated.Value(1);

  useEffect(() => {
    if (currentLocation) {
      startPulseAnimation();
    }
  }, [currentLocation]);

  const startPulseAnimation = () => {
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseValue, {
          toValue: 1.2,
          duration: 1500,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
        Animated.timing(pulseValue, {
          toValue: 1,
          duration: 1500,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: true,
        }),
      ])
    ).start();
  };

  const handleGetLocation = async () => {
    setUpdatingLocation(true);
    try {
      const location = await getCurrentLocation();
      
      if (!location) {
        Alert.alert(
          'Location Error',
          'Failed to get your current location. Please check your location settings and try again.'
        );
      }
    } catch (err) {
      Alert.alert(
        'Location Error',
        'An error occurred while getting your location.'
      );
    } finally {
      setUpdatingLocation(false);
    }
  };

  const handleClearLocation = () => {
    Alert.alert(
      'Clear Location',
      'Are you sure you want to clear your location data?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Clear',
          style: 'destructive',
          onPress: clearLocation,
        },
      ]
    );
  };

  const formatCoordinate = (coord: number): string => {
    return coord.toFixed(6);
  };

  const formatAccuracy = (accuracy: number): string => {
    return `¬±${accuracy.toFixed(1)} meters`;
  };

  if (isLoading && !currentLocation) {
    return (
      <Container>
        <Loading text="Loading location settings..." />
      </Container>
    );
  }

  return (
    <Container>
      <ScrollView style={styles.container}>
        {/* Location Status Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Location Status</Text>
          <View style={styles.card}>
            <Animated.View 
              style={[
                styles.statusIcon,
                { 
                  transform: [{ scale: pulseValue }],
                  backgroundColor: currentLocation 
                    ? Theme.colors.success 
                    : Theme.colors.warning
                }
              ]}
            >
              <Text style={styles.icon}>
                {currentLocation ? 'üìç' : '‚ùì'}
              </Text>
            </Animated.View>
            
            <Text style={styles.statusTitle}>
              {currentLocation ? 'Location Available' : 'No Location Data'}
            </Text>
            
            <Text style={styles.statusDescription}>
              {currentLocation
                ? 'Your current location has been successfully retrieved.'
                : 'Get your current location to see your coordinates and address.'}
            </Text>

            {error && (
              <Text style={styles.errorText}>{error}</Text>
            )}
          </View>
        </View>

        {/* Location Data Section */}
        {currentLocation && (
          <View style={styles.section}>
            <Text style={styles.sectionTitle}>Your Location</Text>
            <View style={styles.card}>
              <View style={styles.coordinates}>
                <View style={styles.coordinateItem}>
                  <Text style={styles.coordinateLabel}>Latitude</Text>
                  <Text style={styles.coordinateValue}>
                    {formatCoordinate(currentLocation.latitude)}
                  </Text>
                </View>
                
                <View style={styles.coordinateItem}>
                  <Text style={styles.coordinateLabel}>Longitude</Text>
                  <Text style={styles.coordinateValue}>
                    {formatCoordinate(currentLocation.longitude)}
                  </Text>
                </View>
                
                <View style={styles.coordinateItem}>
                  <Text style={styles.coordinateLabel}>Accuracy</Text>
                  <Text style={styles.coordinateValue}>
                    {formatAccuracy(currentLocation.accuracy)}
                  </Text>
                </View>
              </View>

              {currentAddress && (
                <View style={styles.addressSection}>
                  <Text style={styles.addressLabel}>Approximate Address</Text>
                  <Text style={styles.addressValue}>{currentAddress}</Text>
                </View>
              )}

              <View style={styles.mapPreview}>
                <Text style={styles.mapPlaceholder}>
                  üó∫Ô∏è Map Preview
                </Text>
                <Text style={styles.mapDescription}>
                  Latitude: {formatCoordinate(currentLocation.latitude)}
                  {'\n'}
                  Longitude: {formatCoordinate(currentLocation.longitude)}
                </Text>
              </View>
            </View>
          </View>
        )}

        {/* Actions Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Actions</Text>
          <View style={styles.card}>
            <Button
              title={currentLocation ? "Update Location" : "Get Current Location"}
              onPress={handleGetLocation}
              loading={updatingLocation}
              disabled={updatingLocation}
              variant="primary"
              size="large"
              style={styles.actionButton}
            />
            
            {currentLocation && (
              <Button
                title="Clear Location"
                onPress={handleClearLocation}
                variant="outline"
                size="large"
                style={styles.actionButton}
              />
            )}
          </View>
        </View>

        {/* Information Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Information</Text>
          <View style={styles.card}>
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Location Access</Text>
              <Text style={styles.infoValue}>
                {currentLocation ? 'Granted' : 'Not Granted'}
              </Text>
            </View>
            
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Last Updated</Text>
              <Text style={styles.infoValue}>
                {currentLocation?.timestamp 
                  ? new Date(currentLocation.timestamp).toLocaleString()
                  : 'Never'
                }
              </Text>
            </View>
            
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Data Usage</Text>
              <Text style={styles.infoValue}>Minimal</Text>
            </View>
            
            <View style={styles.infoItem}>
              <Text style={styles.infoLabel}>Privacy</Text>
              <Text style={styles.infoValue}>Local Only</Text>
            </View>
          </View>
        </View>

        {/* Help Section */}
        <View style={styles.section}>
          <Text style={styles.sectionTitle}>Help</Text>
          <View style={styles.card}>
            <Text style={styles.helpText}>
              Location services help us provide you with better experience:{'\n\n'}
              ‚Ä¢ Your location data is stored locally on your device{'\n'}
              ‚Ä¢ We never share your location with third parties{'\n'}
              ‚Ä¢ Location access can be managed in your device settings{'\n'}
              ‚Ä¢ You can clear location data at any time{'\n\n'}
              To enable location services:{'\n'}
              1. Go to your device Settings{'\n'}
              2. Find "Pokedex App" in the app list{'\n'}
              3. Enable "Location" permission{'\n'}
              4. Choose "While Using the App"{'\n'}
            </Text>
          </View>
        </View>
      </ScrollView>
    </Container>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    padding: Theme.spacing.lg,
  },
  section: {
    marginBottom: Theme.spacing.xl,
  },
  sectionTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.md,
  },
  card: {
    backgroundColor: Theme.colors.card,
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.xl,
    alignItems: 'center',
    ...Theme.shadows.small,
  },
  statusIcon: {
    width: 80,
    height: 80,
    borderRadius: 40,
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
  },
  icon: {
    fontSize: 40,
  },
  statusTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
    textAlign: 'center',
  },
  statusDescription: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    marginBottom: Theme.spacing.lg,
    lineHeight: Theme.typography.lineHeight.md,
  },
  errorText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.error,
    textAlign: 'center',
    marginTop: Theme.spacing.sm,
  },
  coordinates: {
    width: '100%',
    marginBottom: Theme.spacing.lg,
  },
  coordinateItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: Theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
  },
  coordinateLabel: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
  },
  coordinateValue: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
  },
  addressSection: {
    width: '100%',
    marginBottom: Theme.spacing.lg,
  },
  addressLabel: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
    marginBottom: Theme.spacing.sm,
  },
  addressValue: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    lineHeight: Theme.typography.lineHeight.md,
  },
  mapPreview: {
    width: '100%',
    height: 120,
    backgroundColor: Theme.colors.gray[100],
    borderRadius: Theme.borders.radius.medium,
    justifyContent: 'center',
    alignItems: 'center',
    padding: Theme.spacing.md,
  },
  mapPlaceholder: {
    fontSize: Theme.typography.size.lg,
    marginBottom: Theme.spacing.sm,
  },
  mapDescription: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    textAlign: 'center',
    lineHeight: Theme.typography.lineHeight.sm,
  },
  actionButton: {
    width: '100%',
    marginBottom: Theme.spacing.md,
  },
  infoItem: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    paddingVertical: Theme.spacing.md,
    borderBottomWidth: 1,
    borderBottomColor: Theme.colors.borderLight,
    width: '100%',
  },
  infoLabel: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.text.primary,
  },
  infoValue: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
  },
  helpText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.text.secondary,
    lineHeight: Theme.typography.lineHeight.md,
  },
});

export default LocationSettings;./screens/settings/Settings.tsx
==== ./screens/settings/Settings.tsx ====
import React, { useState, useEffect } from 'react';
import {
  View,
  Text,
  StyleSheet,
  ScrollView,
  Animated,
  Easing,
  Dimensions,
  TouchableOpacity,
  Alert,
} from 'react-native';
import { useNavigation } from '@react-navigation/native';
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { FontAwesome6 } from "@react-native-vector-icons/fontawesome6";
import Container from '../../components/layout/Container';
import Button from '../../components/common/Button';
import { Theme } from '../../styles/themes';
import { useAuth } from '../../hooks/useAuth';
import { useBiometric } from '../../hooks/useBiometric';
import { DrawerParamList } from '../../types/navigation';

type SettingsScreenNavigationProp = NativeStackNavigationProp<DrawerParamList>;

const { width: SCREEN_WIDTH, height: SCREEN_HEIGHT } = Dimensions.get('window');

const Settings: React.FC = () => {
  const navigation = useNavigation<SettingsScreenNavigationProp>();
  const { user, logout } = useAuth();
  const { isAvailable, isEnabled } = useBiometric();

  const [pulseAnim] = useState(new Animated.Value(0));
  const [glowAnim] = useState(new Animated.Value(0));
  const [slideAnim] = useState(new Animated.Value(SCREEN_WIDTH));
  const [rotateAnim] = useState(new Animated.Value(0));
  const [fadeAnim] = useState(new Animated.Value(0));

  useEffect(() => {
    startAnimations();
  }, []);

  const startAnimations = () => {
    // Pulse animation for background
    Animated.loop(
      Animated.sequence([
        Animated.timing(pulseAnim, {
          toValue: 1,
          duration: 3000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: false,
        }),
        Animated.timing(pulseAnim, {
          toValue: 0,
          duration: 3000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: false,
        }),
      ])
    ).start();

    // Glow animation
    Animated.loop(
      Animated.sequence([
        Animated.timing(glowAnim, {
          toValue: 1,
          duration: 2000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: false,
        }),
        Animated.timing(glowAnim, {
          toValue: 0.3,
          duration: 2000,
          easing: Easing.inOut(Easing.ease),
          useNativeDriver: false,
        }),
      ])
    ).start();

    // Slide in animation
    Animated.parallel([
      Animated.timing(slideAnim, {
        toValue: 0,
        duration: 800,
        easing: Easing.out(Easing.back(1.2)),
        useNativeDriver: true,
      }),
      Animated.timing(fadeAnim, {
        toValue: 1,
        duration: 800,
        easing: Easing.out(Easing.ease),
        useNativeDriver: true,
      })
    ]).start();

    // Rotating pokeball
    Animated.loop(
      Animated.timing(rotateAnim, {
        toValue: 1,
        duration: 4000,
        easing: Easing.linear,
        useNativeDriver: true,
      })
    ).start();
  };

  const backgroundColor = pulseAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['#1a1a2e', '#16213e'],
  });

  const glowOpacity = glowAnim.interpolate({
    inputRange: [0, 1],
    outputRange: [0.3, 0.8],
  });

  const rotate = rotateAnim.interpolate({
    inputRange: [0, 1],
    outputRange: ['0deg', '360deg'],
  });

  const handleLogout = () => {
    Alert.alert(
      'Logout',
      'Are you sure you want to logout?',
      [
        {
          text: 'Cancel',
          style: 'cancel',
        },
        {
          text: 'Logout',
          style: 'destructive',
          onPress: async () => {
            await logout();
          },
        },
      ]
    );
  };

  const navigateToBiometricSettings = () => {
    navigation.navigate('BiometricSettings');
  };

  const navigateToLocationSettings = () => {
    navigation.navigate('LocationSettings');
  };

  // Custom Gradient Component Replacement
  const GradientView = ({ colors, style, children }: any) => (
    <View style={[style, { overflow: 'hidden' }]}>
      {/* Simulate gradient with multiple layered views */}
      <View style={[StyleSheet.absoluteFill, { backgroundColor: colors[0], opacity: 0.6 }]} />
      <View style={[StyleSheet.absoluteFill, { backgroundColor: colors[1], opacity: 0.8 }]} />
      <View style={[StyleSheet.absoluteFill, { backgroundColor: colors[2], opacity: 0.6 }]} />
      {children}
    </View>
  );

  const MenuItem = ({ 
    icon, 
    title, 
    description, 
    status, 
    onPress, 
    color = Theme.colors.primary,
    isLast = false 
  }: any) => (
    <TouchableOpacity 
      style={[styles.menuItem, isLast && styles.menuItemLast]}
      onPress={onPress}
      activeOpacity={0.7}
    >
      <Animated.View style={[styles.menuIconContainer, { backgroundColor: color + '20' }]}>
        <FontAwesome6 name={icon} size={24} color={color} />
      </Animated.View>
      
      <View style={styles.menuContent}>
        <Text style={styles.menuTitle}>{title}</Text>
        <Text style={styles.menuDescription}>{description}</Text>
      </View>
      
      <View style={styles.menuAction}>
        {status && <Text style={styles.menuStatus}>{status}</Text>}
        <FontAwesome6 name="chevron-right" size={16} color={Theme.colors.text.secondary} iconStyle='solid'/>
      </View>
    </TouchableOpacity>
  );

  return (
    <Container safeArea={false}>
      {/* Animated Background */}
      <Animated.View 
        style={[
          styles.background,
          { backgroundColor }
        ]}
      />
      
      {/* Animated Glow Effects */}
      <Animated.View 
        style={[
          styles.glowEffect,
          styles.glow1,
          { opacity: glowOpacity }
        ]}
      />
      <Animated.View 
        style={[
          styles.glowEffect,
          styles.glow2,
          { opacity: glowAnim }
        ]}
      />

      {/* Floating Pokeballs */}
      <Animated.View 
        style={[
          styles.floatingPokeball,
          styles.pokeball1,
          { transform: [{ rotate }] }
        ]}
      >
        <Text style={styles.pokeballIcon}>‚ö´</Text>
      </Animated.View>
      
      <Animated.View 
        style={[
          styles.floatingPokeball,
          styles.pokeball2,
          { transform: [{ rotate: rotateAnim.interpolate({
            inputRange: [0, 1],
            outputRange: ['0deg', '-360deg']
          }) }] }
        ]}
      >
        <Text style={styles.pokeballIcon}>üî¥</Text>
      </Animated.View>

      <ScrollView 
        style={styles.container}
        showsVerticalScrollIndicator={false}
        contentContainerStyle={styles.scrollContent}
      >
        {/* Header Section with Slide Animation */}
        <Animated.View 
          style={[
            styles.headerSection,
            { 
              transform: [{ translateX: slideAnim }],
              opacity: fadeAnim
            }
          ]}
        >
          <GradientView
            colors={['#DC0A2D', '#FF3B5C', '#DC0A2D']}
            style={styles.headerGradient}
          >
            {/* Profile Avatar with Animated Border */}
            <View style={styles.avatarContainer}>
              <View style={styles.avatarBorder}>
                <View style={styles.avatarGradient}>
                  <View style={styles.avatar}>
                    <FontAwesome6 name="user-astronaut" size={40} color={Theme.colors.white} iconStyle='solid'/>
                  </View>
                </View>
              </View>
              
              {/* Level Badge */}
              <View style={styles.levelBadge}>
                <Text style={styles.levelText}>Lv. 25</Text>
              </View>
            </View>

            <View style={styles.userInfo}>
              <Text style={styles.userName}>{user?.username || 'Pok√©mon Trainer'}</Text>
              <Text style={styles.userTitle}>Pok√©mon Master</Text>
              <Text style={styles.userEmail}>{user?.email}</Text>
            </View>

            {/* Stats Row */}
            <View style={styles.statsContainer}>
              <View style={styles.statItem}>
                <Text style={styles.statNumber}>128</Text>
                <Text style={styles.statLabel}>Pok√©mon</Text>
              </View>
              <View style={styles.statDivider} />
              <View style={styles.statItem}>
                <Text style={styles.statNumber}>47</Text>
                <Text style={styles.statLabel}>Caught</Text>
              </View>
              <View style={styles.statDivider} />
              <View style={styles.statItem}>
                <Text style={styles.statNumber}>81</Text>
                <Text style={styles.statLabel}>Seen</Text>
              </View>
            </View>
          </GradientView>
        </Animated.View>

        {/* Menu Section */}
        <Animated.View 
          style={[
            styles.menuSection,
            { opacity: fadeAnim }
          ]}
        >
          <Text style={styles.sectionTitle}>Trainer Settings</Text>
          
          <View style={styles.menuCard}>
            <MenuItem
              icon="fingerprint"
              title="Biometric Auth"
              description="Secure login with Face ID/Fingerprint"
              status={isEnabled ? "ACTIVE" : "INACTIVE"}
              onPress={navigateToBiometricSettings}
              color="#4ECDC4"
            />
            
            <MenuItem
              icon="location-dot"
              title="Location Services"
              description="Access your current location"
              status="ENABLED"
              onPress={navigateToLocationSettings}
              color="#45B7D1"
            />
            
            <MenuItem
              icon="bell"
              title="Notifications"
              description="Pok√©mon alerts and updates"
              status="ON"
              onPress={() => {}}
              color="#FF6B6B"
            />
            
            <MenuItem
              icon="palette"
              title="Appearance"
              description="Dark mode and themes"
              status="AUTO"
              onPress={() => {}}
              color="#FFD166"
              isLast={true}
            />
          </View>
        </Animated.View>

        {/* Game Stats Section */}
        <Animated.View 
          style={[
            styles.menuSection,
            { opacity: fadeAnim }
          ]}
        >
          <Text style={styles.sectionTitle}>Game Progress</Text>
          
          <View style={styles.statsCard}>
            <View style={styles.progressItem}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>Kanto Dex Completion</Text>
                <Text style={styles.progressPercent}>68%</Text>
              </View>
              <View style={styles.progressBar}>
                <Animated.View style={[styles.progressFill, { width: '68%' }]} />
              </View>
            </View>
            
            <View style={styles.progressItem}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>Johto Discovery</Text>
                <Text style={styles.progressPercent}>42%</Text>
              </View>
              <View style={styles.progressBar}>
                <Animated.View style={[styles.progressFill, { width: '42%', backgroundColor: '#4ECDC4' }]} />
              </View>
            </View>
            
            <View style={styles.progressItem}>
              <View style={styles.progressHeader}>
                <Text style={styles.progressLabel}>Battle Wins</Text>
                <Text style={styles.progressPercent}>156</Text>
              </View>
              <View style={styles.progressBar}>
                <Animated.View style={[styles.progressFill, { width: '85%', backgroundColor: '#FFD166' }]} />
              </View>
            </View>
          </View>
        </Animated.View>

        {/* Achievements Section */}
        <Animated.View 
          style={[
            styles.menuSection,
            { opacity: fadeAnim }
          ]}
        >
          <Text style={styles.sectionTitle}>Recent Achievements</Text>
          
          <View style={styles.achievementsCard}>
            <View style={styles.achievementItem}>
              <View style={[styles.achievementIcon, { backgroundColor: '#FFD700' }]}>
                <FontAwesome6 name="trophy" size={20} color={Theme.colors.white} iconStyle='solid'/>
              </View>
              <View style={styles.achievementContent}>
                <Text style={styles.achievementTitle}>First Pok√©mon</Text>
                <Text style={styles.achievementDesc}>Caught your starter Pok√©mon</Text>
              </View>
              <Text style={styles.achievementTime}>2d ago</Text>
            </View>
            
            <View style={styles.achievementItem}>
              <View style={[styles.achievementIcon, { backgroundColor: '#C0C0C0' }]}>
                <FontAwesome6 name="medal" size={20} color={Theme.colors.white} iconStyle='solid'/>
              </View>
              <View style={styles.achievementContent}>
                <Text style={styles.achievementTitle}>Type Master</Text>
                <Text style={styles.achievementDesc}>Discovered all Pok√©mon types</Text>
              </View>
              <Text style={styles.achievementTime}>1w ago</Text>
            </View>

            <View style={styles.achievementItem}>
              <View style={[styles.achievementIcon, { backgroundColor: '#CD7F32' }]}>
                <FontAwesome6 name="award" size={20} color={Theme.colors.white} iconStyle='solid'/>
              </View>
              <View style={styles.achievementContent}>
                <Text style={styles.achievementTitle}>Gym Leader</Text>
                <Text style={styles.achievementDesc}>Defeated first gym</Text>
              </View>
              <Text style={styles.achievementTime}>3d ago</Text>
            </View>
          </View>
        </Animated.View>

        {/* Logout Button */}
        <Animated.View 
          style={[
            styles.logoutSection,
            { opacity: fadeAnim }
          ]}
        >
          <Button
            title="Logout from Pokedex"
            onPress={handleLogout}
            variant="danger"
            size="large"
            style={styles.logoutButton}
            icon="right-from-bracket"
          />
        </Animated.View>

        {/* Footer */}
        <Animated.View 
          style={[
            styles.footer,
            { opacity: fadeAnim }
          ]}
        >
          <Text style={styles.footerText}>Pokedex App v1.0.0</Text>
          <Text style={styles.footerSubtext}>Gotta Catch 'Em All!</Text>
        </Animated.View>
      </ScrollView>
    </Container>
  );
};

const styles = StyleSheet.create({
  background: {
    position: 'absolute',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
  },
  container: {
    flex: 1,
  },
  scrollContent: {
    paddingBottom: Theme.spacing.xxl,
  },
  glowEffect: {
    position: 'absolute',
    borderRadius: 500,
  },
  glow1: {
    top: -100,
    right: -100,
    width: 300,
    height: 300,
    backgroundColor: '#DC0A2D',
    opacity: 0.3,
  },
  glow2: {
    bottom: -150,
    left: -100,
    width: 400,
    height: 400,
    backgroundColor: '#4ECDC4',
    opacity: 0.2,
  },
  floatingPokeball: {
    position: 'absolute',
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: 30,
  },
  pokeball1: {
    top: SCREEN_HEIGHT * 0.1,
    right: 30,
    width: 60,
    height: 60,
  },
  pokeball2: {
    bottom: SCREEN_HEIGHT * 0.15,
    left: 20,
    width: 40,
    height: 40,
  },
  pokeballIcon: {
    fontSize: 24,
  },
  headerSection: {
    marginBottom: Theme.spacing.xl,
  },
  headerGradient: {
    padding: Theme.spacing.xl,
    paddingTop: Theme.spacing.xxl,
    borderBottomLeftRadius: 40,
    borderBottomRightRadius: 40,
    ...Theme.shadows.large,
  },
  avatarContainer: {
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
  },
  avatarBorder: {
    width: 100,
    height: 100,
    borderRadius: 50,
    padding: 3,
    backgroundColor: '#FFD700', // Gold border
    ...Theme.shadows.medium,
  },
  avatarGradient: {
    width: '100%',
    height: '100%',
    borderRadius: 47,
    backgroundColor: '#FF6B6B',
    justifyContent: 'center',
    alignItems: 'center',
  },
  avatar: {
    width: '100%',
    height: '100%',
    borderRadius: 47,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    justifyContent: 'center',
    alignItems: 'center',
    borderWidth: 2,
    borderColor: 'rgba(255, 255, 255, 0.3)',
  },
  levelBadge: {
    position: 'absolute',
    bottom: -5,
    backgroundColor: Theme.colors.primary,
    paddingHorizontal: Theme.spacing.md,
    paddingVertical: Theme.spacing.xs,
    borderRadius: Theme.borders.radius.round,
    ...Theme.shadows.small,
    borderWidth: 2,
    borderColor: '#FFD700',
  },
  levelText: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
  },
  userInfo: {
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
  },
  userName: {
    fontSize: Theme.typography.size.xxl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.xs,
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 3,
  },
  userTitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
    opacity: 0.9,
    marginBottom: Theme.spacing.xs,
  },
  userEmail: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.7,
  },
  statsContainer: {
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.md,
    marginTop: Theme.spacing.md,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  statItem: {
    alignItems: 'center',
    flex: 1,
  },
  statNumber: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.xs,
  },
  statLabel: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
    opacity: 0.8,
  },
  statDivider: {
    width: 1,
    height: 30,
    backgroundColor: 'rgba(255, 255, 255, 0.3)',
  },
  menuSection: {
    marginBottom: Theme.spacing.xl,
    paddingHorizontal: Theme.spacing.lg,
  },
  sectionTitle: {
    fontSize: Theme.typography.size.xl,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.md,
    textShadowColor: 'rgba(0, 0, 0, 0.3)',
    textShadowOffset: { width: 1, height: 1 },
    textShadowRadius: 2,
  },
  menuCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: Theme.borders.radius.large,
    overflow: 'hidden',
    ...Theme.shadows.medium,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  menuItem: {
    flexDirection: 'row',
    alignItems: 'center',
    padding: Theme.spacing.lg,
    borderBottomWidth: 1,
    borderBottomColor: 'rgba(255, 255, 255, 0.1)',
  },
  menuItemLast: {
    borderBottomWidth: 0,
  },
  menuIconContainer: {
    width: 50,
    height: 50,
    borderRadius: 25,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: Theme.spacing.md,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.2)',
  },
  menuContent: {
    flex: 1,
  },
  menuTitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.xs,
  },
  menuDescription: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.7,
  },
  menuAction: {
    flexDirection: 'row',
    alignItems: 'center',
  },
  menuStatus: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.success,
    marginRight: Theme.spacing.sm,
    backgroundColor: 'rgba(34, 197, 94, 0.2)',
    paddingHorizontal: Theme.spacing.sm,
    paddingVertical: Theme.spacing.xs,
    borderRadius: Theme.borders.radius.small,
    borderWidth: 1,
    borderColor: 'rgba(34, 197, 94, 0.3)',
  },
  statsCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.lg,
    ...Theme.shadows.medium,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  progressItem: {
    marginBottom: Theme.spacing.lg,
  },
  progressHeader: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    marginBottom: Theme.spacing.sm,
  },
  progressLabel: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
  },
  progressPercent: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.bold,
    color: Theme.colors.white,
  },
  progressBar: {
    height: 8,
    backgroundColor: 'rgba(255, 255, 255, 0.2)',
    borderRadius: Theme.borders.radius.small,
    overflow: 'hidden',
  },
  progressFill: {
    height: '100%',
    backgroundColor: Theme.colors.primary,
    borderRadius: Theme.borders.radius.small,
  },
  achievementsCard: {
    backgroundColor: 'rgba(255, 255, 255, 0.1)',
    borderRadius: Theme.borders.radius.large,
    padding: Theme.spacing.lg,
    ...Theme.shadows.medium,
    borderWidth: 1,
    borderColor: 'rgba(255, 255, 255, 0.1)',
  },
  achievementItem: {
    flexDirection: 'row',
    alignItems: 'center',
    marginBottom: Theme.spacing.lg,
  },
  achievementIcon: {
    width: 40,
    height: 40,
    borderRadius: 20,
    justifyContent: 'center',
    alignItems: 'center',
    marginRight: Theme.spacing.md,
    ...Theme.shadows.small,
  },
  achievementContent: {
    flex: 1,
  },
  achievementTitle: {
    fontSize: Theme.typography.size.md,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
    marginBottom: Theme.spacing.xs,
  },
  achievementDesc: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.7,
  },
  achievementTime: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.5,
  },
  logoutSection: {
    paddingHorizontal: Theme.spacing.lg,
    marginTop: Theme.spacing.xl,
  },
  logoutButton: {
    backgroundColor: 'rgba(220, 10, 45, 0.8)',
    borderWidth: 0,
  },
  footer: {
    alignItems: 'center',
    marginTop: Theme.spacing.xxl,
    padding: Theme.spacing.lg,
  },
  footerText: {
    fontSize: Theme.typography.size.sm,
    fontFamily: Theme.typography.family.medium,
    color: Theme.colors.white,
    opacity: 0.7,
    marginBottom: Theme.spacing.xs,
  },
  footerSubtext: {
    fontSize: Theme.typography.size.xs,
    fontFamily: Theme.typography.family.regular,
    color: Theme.colors.white,
    opacity: 0.5,
  },
});

export default Settings;./services/api/pokeapi.ts
==== ./services/api/pokeapi.ts ====
import { Pokemon, PokemonListResponse, PokemonListItem } from '../../types/pokemon';
import { API_BASE_URL } from '../../utils/constans';

class PokeApiService {
  private baseUrl: string = API_BASE_URL;

  async getPokemonList(limit: number = 20, offset: number = 0): Promise<PokemonListResponse> {
    try {
      const response = await fetch(
        `${this.baseUrl}/pokemon?limit=${limit}&offset=${offset}`
      );
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      
      // Process the results to include id
      const processedResults = data.results.map((item: PokemonListItem, index: number) => ({
        ...item,
        id: offset + index + 1
      }));

      return {
        ...data,
        results: processedResults
      };
    } catch (error) {
      console.error('Error fetching Pokemon list:', error);
      throw error;
    }
  }

  async getPokemonDetail(idOrName: string | number): Promise<Pokemon> {
    try {
      const response = await fetch(`${this.baseUrl}/pokemon/${idOrName}`);
      
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      
      const data = await response.json();
      return this.transformPokemonData(data);
    } catch (error) {
      console.error('Error fetching Pokemon detail:', error);
      throw error;
    }
  }

  private transformPokemonData(data: any): Pokemon {
    return {
      id: data.id,
      name: data.name,
      types: data.types,
      stats: data.stats,
      abilities: data.abilities,
      height: data.height,
      weight: data.weight,
      base_experience: data.base_experience,
      sprites: {
        front_default: data.sprites.front_default,
        front_shiny: data.sprites.front_shiny,
        back_default: data.sprites.back_default,
        back_shiny: data.sprites.back_shiny,
        other: {
          'official-artwork': {
            front_default: data.sprites.other['official-artwork'].front_default
          }
        }
      }
    };
  }

  async getPokemonBatch(ids: number[]): Promise<Pokemon[]> {
    try {
      const promises = ids.map(id => this.getPokemonDetail(id));
      return await Promise.all(promises);
    } catch (error) {
      console.error('Error fetching Pokemon batch:', error);
      throw error;
    }
  }
}

export default new PokeApiService();./services/biometrics/biometricAuth.ts
==== ./services/biometrics/biometricAuth.ts ====
import { 
  isSensorAvailable,
  simplePrompt
} from '@sbaiahmed1/react-native-biometrics';
import Keychain from 'react-native-keychain';
import { STORAGE_KEYS } from '../../utils/constans';

class BiometricAuthService {

  async isBiometricAvailable() {
    try {
      const result = await isSensorAvailable();
      return {
        available: result.available,
        biometryType: result.biometryType
      };
    } catch (e) {
      console.log('Biometric check failed:', e);
      return { available: false };
    }
  }

  async enableBiometricAuth(username: string, password: string) {
    try {
      const { available } = await this.isBiometricAvailable();
      if (!available) return false;

      // Prompt biometric
      const { success } = await simplePrompt('Enable biometric login for Pokedex App');
      if (!success) return false;

      // Simpan credentials
      await Keychain.setGenericPassword(username, password, {
        service: STORAGE_KEYS.BIOMETRIC_ENABLED,
        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY
      });

      // Simpan flag biometric aktif
      await Keychain.setGenericPassword('biometric_enabled', 'true', {
        service: STORAGE_KEYS.BIOMETRIC_STATUS,
        accessible: Keychain.ACCESSIBLE.WHEN_UNLOCKED_THIS_DEVICE_ONLY
      });

      return true;

    } catch (e) {
      console.log('Enable biometric error:', e);
      return false;
    }
  }

  async disableBiometricAuth() {
    try {
      await Keychain.resetGenericPassword({ service: STORAGE_KEYS.BIOMETRIC_ENABLED });
      await Keychain.resetGenericPassword({ service: STORAGE_KEYS.BIOMETRIC_STATUS });
      return true;
    } catch (e) {
      console.log('Disable biometric error:', e);
      return false;
    }
  }

  async isBiometricEnabled() {
    try {
      const flag = await Keychain.getGenericPassword({
        service: STORAGE_KEYS.BIOMETRIC_STATUS
      });
      if (!flag) return false;
      return flag?.password === 'true';
    } catch (e) {
      console.log('Check biometric status error:', e);
      return false;
    }
  }

  async getStoredCredentials() {
    try {
      const creds = await Keychain.getGenericPassword({
        service: STORAGE_KEYS.BIOMETRIC_ENABLED
      });

      if (!creds) return null;

      return {
        username: creds.username,
        password: creds.password
      };

    } catch (e) {
      console.log('Get stored credentials error:', e);
      return null;
    }
  }

  async authenticateWithBiometric() {
    try {
      const { success } = await simplePrompt('Authenticate to access Pokedex App');
      if (!success) return { success: false };

      const credentials = await this.getStoredCredentials();
      return { success: true, credentials };

    } catch (e) {
      console.log('Biometric auth error:', e);
      return { success: false };
    }
  }
}

export default new BiometricAuthService();
./services/location/geolocation.ts
==== ./services/location/geolocation.ts ====
import { PermissionsAndroid, Platform } from 'react-native';
import Geolocation from 'react-native-geolocation-service';
import { LocationData } from '../../types/common';

class LocationService {
  async requestPermission(): Promise<boolean> {
    if (Platform.OS === 'android') {
      try {
        const granted = await PermissionsAndroid.request(
          PermissionsAndroid.PERMISSIONS.ACCESS_FINE_LOCATION,
          {
            title: 'Izin Lokasi',
            message: 'Aplikasi membutuhkan akses lokasi untuk menampilkan koordinat Anda.',
            buttonNeutral: 'Tanya Nanti',
            buttonNegative: 'Tolak',
            buttonPositive: 'Izinkan',
          }
        );
        return granted === PermissionsAndroid.RESULTS.GRANTED;
      } catch (error) {
        console.error('Error requesting location permission:', error);
        return false;
      }
    }
    
    // For iOS, ensure you have NSLocationWhenInUseUsageDescription in Info.plist
    return true;
  }

  async getCurrentLocation(): Promise<LocationData> {
    const hasPermission = await this.requestPermission();
    
    if (!hasPermission) {
      throw new Error('Location permission denied');
    }

    return new Promise((resolve, reject) => {
      Geolocation.getCurrentPosition(
        (position) => {
          resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude,
            accuracy: position.coords.accuracy,
            timestamp: position.timestamp,
          });
        },
        (error) => {
          reject(error);
        },
        { 
          enableHighAccuracy: true, 
          timeout: 15000, 
          maximumAge: 10000,
          distanceFilter: 10,
        }
      );
    });
  }

  async getCurrentAddress(latitude: number, longitude: number): Promise<string> {
    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=json&lat=${latitude}&lon=${longitude}&zoom=18&addressdetails=1`
      );
      
      if (!response.ok) {
        throw new Error('Failed to fetch address');
      }
      
      const data = await response.json();
      return data.display_name || 'Address not available';
    } catch (error) {
      console.error('Error getting address:', error);
      return 'Address not available';
    }
  }
}

export default new LocationService();./services/storage/auth.ts
==== ./services/storage/auth.ts ====
import Keychain from 'react-native-keychain';
import { User, AuthCredentials } from '../../types/auth';
import { STORAGE_KEYS } from '../../utils/constans';

class AuthStorageService {
    private serviceName = 'pokedex-app';

    async saveUserCredentials(credentials: AuthCredentials, user: User): Promise<boolean> {
        try {
            // Save credentials to keychain
            await Keychain.setGenericPassword(
                credentials.email,
                credentials.password,
                { service: this.serviceName }
            );

            // Save user data to secure storage
            await Keychain.setInternetCredentials(
                STORAGE_KEYS.USER_DATA,
                user.id,
                JSON.stringify(user),
                { service: this.serviceName }
            );

            return true;
        } catch (error) {
            console.error('Error saving user credentials:', error);
            return false;
        }
    }

    async getUserCredentials(): Promise<{ username: string; password: string } | null> {
        try {
            const credentials = await Keychain.getGenericPassword({ service: this.serviceName });
            if (credentials) {
                return {
                    username: credentials.username,
                    password: credentials.password,
                };
            }
            return null;
        } catch (error) {
            console.error('Error getting user credentials:', error);
            return null;
        }
    }

    async getUserData(): Promise<User | null> {
        try {
            const credentials = await Keychain.getInternetCredentials(STORAGE_KEYS.USER_DATA);
            if (credentials && credentials.password) {
                return JSON.parse(credentials.password);
            }
            return null;
        } catch (error) {
            console.error('Error getting user data:', error);
            return null;
        }
    }

    async clearUserData(): Promise<boolean> {
        try {
            await Keychain.resetGenericPassword({ service: this.serviceName });
            await Keychain.resetInternetCredentials({
                service: STORAGE_KEYS.USER_DATA
            })
            return true;
        } catch (error) {
            console.error('Error clearing user data:', error);
            return false;
        }
    }

    async isUserLoggedIn(): Promise<boolean> {
        try {
            const credentials = await this.getUserCredentials();
            return !!credentials;
        } catch (error) {
            console.error('Error checking login status:', error);
            return false;
        }
    }
}

export default new AuthStorageService();./services/storage/favorites.ts
==== ./services/storage/favorites.ts ====
import AsyncStorage from '@react-native-async-storage/async-storage';
import { STORAGE_KEYS } from '../../utils/constans';

class FavoritesStorageService {
  private key = STORAGE_KEYS.FAVORITES;

  async getFavorites(): Promise<number[]> {
    try {
      const favorites = await AsyncStorage.getItem(this.key);
      return favorites ? JSON.parse(favorites) : [];
    } catch (error) {
      console.error('Error getting favorites:', error);
      return [];
    }
  }

  async addFavorite(pokemonId: number): Promise<boolean> {
    try {
      const favorites = await this.getFavorites();
      if (!favorites.includes(pokemonId)) {
        favorites.push(pokemonId);
        await AsyncStorage.setItem(this.key, JSON.stringify(favorites));
      }
      return true;
    } catch (error) {
      console.error('Error adding favorite:', error);
      return false;
    }
  }

  async removeFavorite(pokemonId: number): Promise<boolean> {
    try {
      const favorites = await this.getFavorites();
      const updatedFavorites = favorites.filter(id => id !== pokemonId);
      await AsyncStorage.setItem(this.key, JSON.stringify(updatedFavorites));
      return true;
    } catch (error) {
      console.error('Error removing favorite:', error);
      return false;
    }
  }

  async isFavorite(pokemonId: number): Promise<boolean> {
    try {
      const favorites = await this.getFavorites();
      return favorites.includes(pokemonId);
    } catch (error) {
      console.error('Error checking favorite:', error);
      return false;
    }
  }

  async clearFavorites(): Promise<boolean> {
    try {
      await AsyncStorage.removeItem(this.key);
      return true;
    } catch (error) {
      console.error('Error clearing favorites:', error);
      return false;
    }
  }
}

export default new FavoritesStorageService();./src.txt
==== ./src.txt ====
./styles/colors.ts
==== ./styles/colors.ts ====
export const Colors = {
  primary: '#DC0A2D',
  primaryDark: '#B80623',
  primaryLight: '#FF3B5C',
  secondary: '#2D5B9A',
  secondaryDark: '#1E3D6F',
  secondaryLight: '#4A7FC8',
  types: {
    normal: '#A8A878',
    fire: '#F08030',
    water: '#6890F0',
    electric: '#F8D030',
    grass: '#78C850',
    ice: '#98D8D8',
    fighting: '#C03028',
    poison: '#A040A0',
    ground: '#E0C068',
    flying: '#A890F0',
    psychic: '#F85888',
    bug: '#A8B820',
    rock: '#B8A038',
    ghost: '#705898',
    dragon: '#7038F8',
    dark: '#705848',
    steel: '#B8B8D0',
    fairy: '#EE99AC',
  },
  white: '#FFFFFF',
  black: '#000000',
  gray: {
    50: '#F8F9FA',
    100: '#E9ECEF',
    200: '#DEE2E6',
    300: '#CED4DA',
    400: '#ADB5BD',
    500: '#6C757D',
    600: '#495057',
    700: '#343A40',
    800: '#212529',
    900: '#121416',
  },
  success: '#28A745',
  warning: '#FFC107',
  error: '#DC3545',
  info: '#17A2B8',
  background: '#F8F9FA',
  surface: '#FFFFFF',
  card: '#FFFFFF',
  text: {
    primary: '#212529',
    secondary: '#6C757D',
    disabled: '#ADB5BD',
    inverse: '#FFFFFF',
  },
  border: '#DEE2E6',
  borderLight: '#E9ECEF',
  borderDark: '#CED4DA',
};./styles/spacing.ts
==== ./styles/spacing.ts ====
export const Spacing = {
  xs: 4,
  sm: 8,
  md: 16,
  lg: 24,
  xl: 32,
  xxl: 48,
  xxxl: 64,
  screenPadding: 16,
  cardPadding: 16,
  sectionPadding: 24,
  buttonPadding: {
    small: { vertical: 8, horizontal: 12 },
    medium: { vertical: 12, horizontal: 16 },
    large: { vertical: 16, horizontal: 24 },
  },
  inputPadding: {
    vertical: 12,
    horizontal: 16,
  },
};./styles/themes.ts
==== ./styles/themes.ts ====
import { Colors } from './colors';
import { Spacing } from './spacing';
import { Typography } from './typography';

export const Theme = {
  colors: Colors,
  spacing: Spacing,
  typography: Typography,
  shadows: {
    small: {
      shadowColor: Colors.black,
      shadowOffset: { width: 0, height: 2 },
      shadowOpacity: 0.1,
      shadowRadius: 3,
      elevation: 2,
    },
    medium: {
      shadowColor: Colors.black,
      shadowOffset: { width: 0, height: 4 },
      shadowOpacity: 0.15,
      shadowRadius: 6,
      elevation: 4,
    },
    large: {
      shadowColor: Colors.black,
      shadowOffset: { width: 0, height: 8 },
      shadowOpacity: 0.2,
      shadowRadius: 12,
      elevation: 8,
    },
  },
  borders: {
    radius: {
      small: 4,
      medium: 8,
      large: 12,
      xlarge: 16,
      round: 50,
    },
    width: {
      thin: 1,
      medium: 2,
      thick: 3,
    },
  },
};./styles/typography.ts
==== ./styles/typography.ts ====
import { Platform } from 'react-native';

export const Typography = {
  family: {
    regular: Platform.OS === 'ios' ? 'System' : 'Roboto',
    medium: Platform.OS === 'ios' ? 'System' : 'Roboto-Medium',
    bold: Platform.OS === 'ios' ? 'System' : 'Roboto-Bold',
    light: Platform.OS === 'ios' ? 'System' : 'Roboto-Light',
  },
  size: {
    xs: 12,
    sm: 14,
    md: 16,
    lg: 18,
    xl: 20,
    xxl: 24,
    xxxl: 32,
    display: 40,
  },
  lineHeight: {
    xs: 16,
    sm: 20,
    md: 24,
    lg: 28,
    xl: 32,
    xxl: 36,
    xxxl: 40,
    display: 48,
  },
  weight: {
    light: '300',
    regular: '400',
    medium: '500',
    semiBold: '600',
    bold: '700',
  },
  styles: {
    display: {
      fontSize: 40,
      lineHeight: 48,
      fontFamily: 'bold',
      fontWeight: '700',
    },
    h1: {
      fontSize: 32,
      lineHeight: 40,
      fontFamily: 'bold',
      fontWeight: '700',
    },
    h2: {
      fontSize: 24,
      lineHeight: 32,
      fontFamily: 'bold',
      fontWeight: '700',
    },
    h3: {
      fontSize: 20,
      lineHeight: 28,
      fontFamily: 'bold',
      fontWeight: '700',
    },
    body: {
      fontSize: 16,
      lineHeight: 24,
      fontFamily: 'regular',
      fontWeight: '400',
    },
    caption: {
      fontSize: 14,
      lineHeight: 20,
      fontFamily: 'regular',
      fontWeight: '400',
    },
    small: {
      fontSize: 12,
      lineHeight: 16,
      fontFamily: 'regular',
      fontWeight: '400',
    },
  },
};./types/auth.ts
==== ./types/auth.ts ====
export interface User {
  id: string;
  email: string;
  username: string;
  createdAt: Date;
}

export interface AuthCredentials {
  email: string;
  password: string;
}

export interface RegisterData extends AuthCredentials {
  username: string;
  confirmPassword: string;
}

export interface BiometricData {
  isEnabled: boolean;
  type: 'faceId' | 'fingerprint' | 'none';
  enrolled: boolean;
}./types/common.ts
==== ./types/common.ts ====
export interface ApiResponse<T> {
  data: T;
  status: number;
  message?: string;
}

export interface PaginationParams {
  limit: number;
  offset: number;
}

export interface LocationData {
  latitude: number;
  longitude: number;
  accuracy: number;
  timestamp?: number;
}

export interface ThemeColors {
  primary: string;
  primaryDark: string;
  primaryLight: string;
  secondary: string;
  background: string;
  surface: string;
  text: string;
}./types/navigation.ts
==== ./types/navigation.ts ====
import { NativeStackNavigationProp } from '@react-navigation/native-stack';
import { NavigatorScreenParams, RouteProp } from '@react-navigation/native';

export type RootStackParamList = {
  Auth: NavigatorScreenParams<AuthStackParamList>;
  Main: undefined;
  PokemonDetail: { pokemonId: number; pokemonName: string };
  NotFound: { error?: string };
  BiometricSetup: undefined;
  LocationSetup: undefined;
};

export type AuthStackParamList = {
  Login: undefined;
  Register: undefined;
};

export type MainTabParamList = {
  PokemonList: undefined;
  Favorites: undefined;
  Settings: undefined;
  BiometricSetup: undefined;
  LocationSetup: undefined;
};

export type DrawerParamList = {
  MainTabs: undefined;
  Settings: undefined;
  BiometricSettings: undefined;
  LocationSettings: undefined;
};

export type MainStackParamList = {
  PokemonList: undefined;
  PokemonDetail: { pokemonId: number; pokemonName: string };
  Favorites: undefined;
  Settings: undefined;
  BiometricSettings: undefined;
  LocationSettings: undefined;
};

export type PokemonDetailScreenNavigationProp = NativeStackNavigationProp<
  RootStackParamList,
  'PokemonDetail'
>;

export type PokemonDetailScreenRouteProp = RouteProp<
  RootStackParamList,
  'PokemonDetail'
>;./types/pokemon.ts
==== ./types/pokemon.ts ====
export interface Pokemon {
  id: number;
  name: string;
  types: PokemonType[];
  stats: PokemonStat[];
  abilities: PokemonAbility[];
  height: number;
  weight: number;
  sprites: PokemonSprites;
  base_experience: number;
}

export interface PokemonType {
  slot: number;
  type: {
    name: string;
    url: string;
  };
}

export interface PokemonStat {
  base_stat: number;
  effort: number;
  stat: {
    name: string;
    url: string;
  };
}

export interface PokemonAbility {
  ability: {
    name: string;
    url: string;
  };
  is_hidden: boolean;
  slot: number;
}

export interface PokemonSprites {
  front_default: string;
  front_shiny: string;
  back_default: string;
  back_shiny: string;
  other: {
    'official-artwork': {
      front_default: string;
    };
  };
}

export interface PokemonListResponse {
  count: number;
  next: string | null;
  previous: string | null;
  results: PokemonListItem[];
}

export interface PokemonListItem {
  name: string;
  url: string;
  id?: number;
}./utils/constans.ts
==== ./utils/constans.ts ====
export const API_BASE_URL = 'https://pokeapi.co/api/v2';
export const POKEMON_LIMIT = 20;
export const POKEMON_IMAGE_BASE_URL = 'https://raw.githubusercontent.com/PokeAPI/sprites/master/sprites/pokemon';

export const STORAGE_KEYS = {
  USER_DATA: 'user_data',
  FAVORITES: 'favorites',
  BIOMETRIC_ENABLED: 'biometric_enabled',
  BIOMETRIC_STATUS: 'BIOMETRIC_STATUS'
};

export const BIOMETRIC_TYPE = {
  FACE_ID: 'FaceID',
  FINGERPRINT: 'Fingerprint',
  NONE: 'None',
};./utils/helpers.ts
==== ./utils/helpers.ts ====
import { Colors } from '../styles/colors';

export const capitalizeFirst = (str: string): string => {
  return str.charAt(0).toUpperCase() + str.slice(1);
};

export const getTypeColor = (type: string): string => {
  const typeColors: { [key: string]: string } = Colors.types;
  return typeColors[type] || Colors.gray[400];
};

export const formatNumber = (num: number): string => {
  return `#${num.toString().padStart(3, '0')}`;
};

export const formatHeight = (height: number): string => {
  return `${(height / 10).toFixed(1)} m`;
};

export const formatWeight = (weight: number): string => {
  return `${(weight / 10).toFixed(1)} kg`;
};